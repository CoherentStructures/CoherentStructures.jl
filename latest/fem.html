<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>FEM-based methods · CoherentStructures.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CoherentStructures.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="rot_double_gyre.html">Rotating Double Gyre</a></li><li><a class="toctext" href="ocean_flow.html">Geostrophic Ocean Flow</a></li><li><a class="toctext" href="bickley.html">Bickley Jet</a></li><li><a class="toctext" href="standard_map.html">Standard Map</a></li></ul></li><li><a class="toctext" href="basics.html">Basics</a></li><li><span class="toctext">Methods</span><ul><li class="current"><a class="toctext" href="fem.html">FEM-based methods</a><ul class="internal"><li><a class="toctext" href="#Features-1">Features</a></li><li><a class="toctext" href="#The-gridContext-Type-1">The <code>gridContext</code> Type</a></li><li><a class="toctext" href="#Assembly-1">Assembly</a></li><li><a class="toctext" href="#Evaluating-Functions-in-the-Approximation-Space-1">Evaluating Functions in the Approximation Space</a></li><li><a class="toctext" href="#Nodal-Interpolation-1">Nodal Interpolation</a></li><li><a class="toctext" href="#Boundary-Conditions-1">Boundary Conditions</a></li><li><a class="toctext" href="#Plotting-and-Videos-1">Plotting and Videos</a></li><li><a class="toctext" href="#Parallelisation-1">Parallelisation</a></li><li><a class="toctext" href="#FEM-API-1">FEM-API</a></li></ul></li><li><a class="toctext" href="elliptic.html">Geodesic vortices</a></li><li><a class="toctext" href="Laplace.html">Graph Laplacian-based methods</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Methods</li><li><a href="fem.html">FEM-based methods</a></li></ul><a class="edit-page" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/master/docs/src/fem.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>FEM-based methods</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="FEM-based-Methods-1" href="#FEM-based-Methods-1">FEM-based Methods</a></h1><p>These methods rely on the theory outlined by Froyland&#39;s <a href="http://arxiv.org/pdf/1411.7186v4.pdf"><em>Dynamical Laplacian</em></a> and the <a href="https://www.researchgate.net/publication/306291640_A_geometric_heat-flow_theory_of_Lagrangian_coherent_structures"><em>Geometric Heat Flow</em></a> of Karrasch &amp; Keller.</p><p>The Laplace-like operators are best discretized by finite-element-based methods, see this <a href="https://arxiv.org/pdf/1705.03640.pdf">paper</a> by Froyland &amp; Junge.</p><p>This involves the discretization of the average of a one-parameter family of Laplace operators of the form:</p><div>\[\Delta^{dyn} := \sum_{t \in \mathcal T} P_t^* \Delta P_t\]</div><p>for a finite series of times <span>$\mathcal T$</span>, where <span>$P_t$</span> is the transfer-operator for the flow at time <span>$t$</span> (in volume-preserving flows).</p><p>The resulting operator is both symmetric and uniformly elliptic. Eigenfunctions of <span>$\Delta^{dyn}$</span> can be used to find Lagrangian Coherent Structures.</p><p>See the <a href="examples.html#Examples-1">Examples</a> section for examples of how these methods can be used.</p><h2><a class="nav-anchor" id="Features-1" href="#Features-1">Features</a></h2><h3><a class="nav-anchor" id="CG-and-TO-methods-1" href="#CG-and-TO-methods-1">CG and TO methods</a></h3><p>The standard Galerkin formulation of the weak dynamical Laplace is refered to as the CG-method here, due to the fact that the inverse Cauchy-Green tensor appears in the weak formulation. This gives a bilinear form <span>$\overline a(u,v) := \sum_{t \in \mathcal T}a^t(P_t u, P_t v)$</span> Here <span>$P_t$</span> is the Transfer-Operator (or pushforward) to time-<span>$t$</span>, and <span>$a^t$</span> is the weak-form of the Laplacian on the range of the time-<span>$t$</span> map being considered.   There are also a range of Transfer-Operator based approaches implemented here. These approximate the weak form of the Dynamical-Laplace by a bilinear-form:</p><div>\[\tilde a_h(u,v) = \sum_{t \in \mathcal T} a^t(I_hP_t u, I_h P_t v)\]</div><p>where <span>$I_h$</span> is a suitable interpolation operator depending on the mesh-width <span>$h$</span>. Options for <span>$I_h$</span> implemented in this package are:</p><ul><li>Collocation (pointwise interpolation)...<ul><li>Points used are mesh points from domain grid (&quot;adaptive TO&quot;)</li><li>Points usedare arbitrary(&quot;non-adaptive TO&quot;)</li></ul></li><li>the <span>$L^2$</span>-orthogonal projection onto a FEM-space<ul><li>Using the forwards flow map (currently gives poor results)</li><li>Using the inverse flow map</li></ul></li></ul><p>Note that the <span>$L^2$</span>-Galerkin methods currently perform very poorly on larger problems.</p><p>For more details, see <a href="https://arxiv.org/pdf/1705.03640.pdf">this paper</a>.</p><h3><a class="nav-anchor" id="Grids-1" href="#Grids-1">Grids</a></h3><p>Note that irregular meshes currently do not work in Julia 1.0, the documentation has not been changed to reflect this.</p><p>Various types of regular and irregular meshes (with Delaunay triangulation using <a href="https://github.com/JuliaGeometry/VoronoiDelaunay.jl">VoronoiDelaunay.jl</a> ) are supported. These are based on the corresponding elements from <a href="https://github.com/KristofferC/JuAFEM.jl">JuAFEM.jl</a> and include:</p><ul><li>Triangular P1-Lagrange elements in 2D (all methods)</li><li>Quadrilateral P1-Lagrange elements in 2D (all methods except adaptive TO)</li><li>Triangular and Quadrilateral P2-Lagrange elements in 2D (all methods except adaptive TO)</li><li>Tetrahedral P1-Lagrange elements in 3D (only CG method tested, non-adaptive TO might work also)</li></ul><h2><a class="nav-anchor" id="The-gridContext-Type-1" href="#The-gridContext-Type-1">The <code>gridContext</code> Type</a></h2><p>The FEM-based methods of <code>CoherentStructures.jl</code> rely heavily on the <a href="https://github.com/KristofferC/JuAFEM.jl">JuAFEM.jl</a> package. This package is very low-level and does not provide point-location/plotting functionality. To be able to more conveniently work with the specific types of grids that we need, all necessary variables for a single grid are combined in a <code>gridContext</code> structure - including the grid points, the quadrature formula used and the type of element used (e.g. Triangular P1, Quadrilateral P2, etc..). This makes it easier to assemble mass/stiffness matrices, and provides an interface for point-location and plotting.</p><p>In this documentation, the variable name <code>ctx</code> is exclusively used for <code>gridContext</code> objects.</p><p>See also <a href="fem.html#Constructing-Grids-1">Constructing Grids</a> in the <a href="fem.html#FEM-API-1">FEM-API</a> section.</p><h3><a class="nav-anchor" id="Node-ordering-and-dof-ordering-1" href="#Node-ordering-and-dof-ordering-1">Node ordering and dof ordering</a></h3><p>Finite Element methods work with degrees of freedom (dof), which are elements of some dual space. For nodal finite elements, these correspond to evaluation functionals at the nodes of the grid.</p><p>The nodes of the grid can be obtained in the following way <code>[n.x for n in ctx.grid.nodes]</code>. However, most of the methods of this package do <em>not</em> return results in this order, but instead use <code>JuAFEM.jl</code>&#39;s dof-ordering.</p><p>See also the documentation in <a href="fem.html#CoherentStructures.dof2node"><code>dof2node</code></a> and <a href="fem.html#CoherentStructures.gridContext"><code>CoherentStructures.gridContext</code></a></p><p>When working with (non-natural) <a href="fem.html#Boundary-Conditions-1">Boundary Conditions</a>, the ordering is further changed, due to there being fewer degrees of freedom in total.</p><h2><a class="nav-anchor" id="Assembly-1" href="#Assembly-1">Assembly</a></h2><p>See <a href="fem.html#Stiffness-and-Mass-Matrices-1">Stiffness and Mass Matrices</a> from the <a href="fem.html#FEM-API-1">FEM-API</a> section.</p><h2><a class="nav-anchor" id="Evaluating-Functions-in-the-Approximation-Space-1" href="#Evaluating-Functions-in-the-Approximation-Space-1">Evaluating Functions in the Approximation Space</a></h2><p>given a series of coefficients that represent a function in the approximation space, to evaluate a function at a point, use the <code>evaluate_function_from_nodevals</code> or <code>evaluate_function_from_dofvals</code> functions.</p><pre><code class="language-">using CoherentStructures #hide
using Plots
ctx = regularP2TriangularGrid((10,10))
u = zeros(ctx.n)
u[45] = 1.0
Plots.heatmap(range(0,stop=1,length=200),range(0,stop=1,length=200), (x,y)-&gt;evaluate_function_from_nodevals(ctx,u,[x,y]))</code></pre><p>For more details, consult the API: <a href="fem.html#CoherentStructures.evaluate_function_from_dofvals"><code>evaluate_function_from_dofvals</code></a>, <a href="fem.html#CoherentStructures.evaluate_function_from_nodevals"><code>evaluate_function_from_nodevals</code></a></p><h2><a class="nav-anchor" id="Nodal-Interpolation-1" href="#Nodal-Interpolation-1">Nodal Interpolation</a></h2><p>To perform nodal interpolation of a grid, use the <a href="fem.html#CoherentStructures.nodal_interpolation"><code>nodal_interpolation</code></a> function.</p><h2><a class="nav-anchor" id="Boundary-Conditions-1" href="#Boundary-Conditions-1">Boundary Conditions</a></h2><p>To use something other than the natural homogeneous von Neumann boundary conditions, the <code>CoherentStructures.boundaryData</code> type can be used. This currently supports combinations of homogeneous Dirichlet and periodic boundary conditions.</p><ul><li>Homogeneous Dirichlet BCs require rows and columns of the stiffness/mass matrices to be deleted</li><li>Periodic boundary conditions require rows and columns of the stiffness/mass matrices to be added to each other.</li></ul><p>This means that the coefficient vectors for elements of the approximation space that satisfy the boundary conditions are potentially smaller and in a different order. Given a <code>bdata</code> argument, functions like <code>plot_u</code> will take this into account.</p><h3><a class="nav-anchor" id="Constructing-Boundary-Conditions-1" href="#Constructing-Boundary-Conditions-1">Constructing Boundary Conditions</a></h3><p>Natural von-Neumann boundary conditions can be constructed with: <code>boundaryData()</code> and are generally the default</p><p>Homogeneous Dirichlet boundary conditions can be constructed with the <code>getHomDBCS(ctx,[which=&quot;all&quot;])</code> function. The optional <code>which</code> parameter is a vector of strings, corresponding to <code>JuAFEM</code> face-sets, e.g. <code>getHomDBCS(ctx,which=[&quot;left&quot;,&quot;right&quot;])</code></p><p>Periodic boundary conditions are constructed by calling <code>boundaryData(ctx,predicate,[which_dbc=[]])</code>. The argument <code>predicate</code> is a function that should return <code>true</code> if and only if two points should be identified. Due to floating-point rounding errors, note that using exact comparisons (<code>==</code>) should be avoided. Only points that are in <code>JuAFEM.jl</code> boundary facesets are considered. If this is too restrictive, use the <code>boundaryData(dbc_dofs, periodic_dofs_from,periodic_dofs_to)</code> constructor.</p><p>For details, see <a href="fem.html#CoherentStructures.boundaryData"><code>boundaryData</code></a></p><h3><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h3><p>Here we apply Homogeneous DBC to top and bottom, and identify the left and right side:</p><pre><code class="language-">using CoherentStructures
ctx = regularQuadrilateralGrid((10,10))
predicate = (p1,p2) -&gt; abs(p1[2] - p2[2]) &lt; 1e-10 &amp;&amp; peuclidean(p1[1],p2[1],1.0) &lt; 1e-10
bdata = boundaryData(ctx,predicate,[&quot;top&quot;,&quot;bottom&quot;])
u = ones(nDofs(ctx,bdata))
u[20] = 2.0; u[38] = 3.0; u[56] = 4.0
plot_u(ctx,u,200,200,bdata=bdata,colorbar=:none)</code></pre><p>To apply boundary conditions to a stiffness/mass matrix, use the <code>applyBCS</code> function. Note that <code>assembleStiffnessMatrix</code> and <code>assembleMassMatrix</code> take a <code>bdata</code> argument that does this internally.</p><h2><a class="nav-anchor" id="Plotting-and-Videos-1" href="#Plotting-and-Videos-1">Plotting and Videos</a></h2><p>There are some helper functions that exist for making plots and videos of functions on grids. These rely on the <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a> library. Plotting recipes are unfortunately not implemented.</p><p>The simplest way to plot is using the <a href="fem.html#CoherentStructures.plot_u"><code>plot_u</code></a> function. Plots and videos of eulerian plots like <span>$f \circ \Phi^0_t$</span> can be made with the <a href="fem.html#CoherentStructures.plot_u_eulerian"><code>plot_u_eulerian</code></a> and  <a href="fem.html#CoherentStructures.eulerian_videos"><code>eulerian_videos</code></a> functions.</p><h2><a class="nav-anchor" id="Parallelisation-1" href="#Parallelisation-1">Parallelisation</a></h2><p>Many of the plotting functions support parallelism internally. Tensor fields can be constructed in parallel, and then passed to <a href="fem.html#CoherentStructures.assembleStiffnessMatrix"><code>assembleStiffnessMatrix</code></a>. For an example that does this, see TODO: Add this example</p><h2><a class="nav-anchor" id="FEM-API-1" href="#FEM-API-1">FEM-API</a></h2><h3><a class="nav-anchor" id="Stiffness-and-Mass-Matrices-1" href="#Stiffness-and-Mass-Matrices-1">Stiffness and Mass Matrices</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.assembleStiffnessMatrix" href="#CoherentStructures.assembleStiffnessMatrix"><code>CoherentStructures.assembleStiffnessMatrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">assembleStiffnessMatrix(ctx,A,[p; bdata])</code></pre><p>Assemble the stiffness-matrix for a symmetric bilinear form</p><div>\[a(u,v) = \int \nabla u(x)\cdot A(x)\nabla v(x)f(x) dx\]</div><p>The integral is approximated using quadrature. <code>A</code> is a function that returns a <code>Tensors.SymmetricTensor{2,dim}</code> and has one of the following forms:</p><ul><li><code>A(x::Vector{Float64})</code></li><li><code>A(x::Vec{dim})</code></li><li><code>A(x::Vec{dim}, index::Int, p)</code>. Here x is equal to <code>ctx.quadrature_points[index]</code>, and <code>p</code> is that which is passed to <code>assembleStiffnessMatrix</code></li></ul><p>The ordering of the result is in dof order, except that boundary conditions from <code>bdata</code> are applied. The default is natural boundary conditions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/FEMassembly.jl#L12-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.assembleMassMatrix" href="#CoherentStructures.assembleMassMatrix"><code>CoherentStructures.assembleMassMatrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">assembleMassMatrix(ctx;[bdata,lumped=false])</code></pre><p>Assemble the mass matrix</p><div>\[M_{i,j} = \int \varphi_j(x) \varphi_i(x) f(x)d\lambda^d\]</div><p>The integral is approximated using numerical quadrature. The values of <code>f(x)</code> are taken from <code>ctx.mass_weights</code>, and should be ordered in the same way as <code>ctx.quadrature_points</code></p><p>The result is ordered in a way so as to be usable with a stiffness matrix with boundary data <code>bdata</code>.</p><p>Returns a lumped mass matrix if <code>lumped==true</code>.</p><p><strong>Example</strong></p><pre><code class="language-none">ctx.mass_weights = map(f, ctx.quadrature_points)
M = assembleMassMatrix(ctx)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/FEMassembly.jl#L106-L126">source</a></section><h3><a class="nav-anchor" id="Constructing-Grids-1" href="#Constructing-Grids-1">Constructing Grids</a></h3><p>There are several helper functions available for constructing grids. The simplest is:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.regular2DGrid" href="#CoherentStructures.regular2DGrid"><code>CoherentStructures.regular2DGrid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">regular2DGrid(gridType, numnodes, LL=[0.0,0.0],UR=[1.0,1.0];quadrature_order=default_quadrature_order)</code></pre><p>Constructs a regular grid. <code>gridType</code> should be from <code>CoherentStructures.regular2DGridTypes</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/gridfunctions.jl#L86-L90">source</a></section><p>Supported values for the <code>gridType</code> argument are:</p><pre><code class="language-">using CoherentStructures #hide
CoherentStructures.regular2DGridTypes</code></pre><p>The following functions are conceptually similar:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.regularTriangularGrid" href="#CoherentStructures.regularTriangularGrid"><code>CoherentStructures.regularTriangularGrid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">regularTriangularGrid(numnodes=(25,25), LL=[0.0,0.0],UR=[1.0,1.0], quadrature_order=default_quadrature_order)</code></pre><p>Create a regular P1 triangular grid on a rectangle; it does not use Delaunay triangulation internally.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/gridfunctions.jl#L252-L256">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.regularP2TriangularGrid" href="#CoherentStructures.regularP2TriangularGrid"><code>CoherentStructures.regularP2TriangularGrid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">regularP2TriangularGrid(numnodes=(25,25), LL=[0.0,0.0],UR=[1.0,1.0],quadrature_order=default_quadrature_order)</code></pre><p>Create a regular P2 triangular grid on a Rectangle. Does not use Delaunay triangulation internally.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/gridfunctions.jl#L288-L292">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.regularQuadrilateralGrid" href="#CoherentStructures.regularQuadrilateralGrid"><code>CoherentStructures.regularQuadrilateralGrid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">regularP2QuadrilateralGrid(numnodes=(25,25), LL=[0.0,0.0],UR=[1.0,1.0],quadrature_order=default_quadrature_order)</code></pre><p>Create a regular P1 quadrilateral grid on a Rectangle.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/gridfunctions.jl#L328-L332">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.regularP2QuadrilateralGrid" href="#CoherentStructures.regularP2QuadrilateralGrid"><code>CoherentStructures.regularP2QuadrilateralGrid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">regularP2QuadrilateralGrid(numnodes=(25,25), LL=[0.0,0.0], UR=[1.0,1.0], quadrature_order=default_quadrature_order)</code></pre><p>Create a regular P2 quadrilateral grid on a rectangle.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/gridfunctions.jl#L372-L376">source</a></section><p>In 3D we have</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.regularTetrahedralGrid" href="#CoherentStructures.regularTetrahedralGrid"><code>CoherentStructures.regularTetrahedralGrid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">regularTetrahedralGrid(numnodes=(10,10,10), LL=[0.0,0.0,0.0], UR=[1.0,1.0,1.0], quadrature_order=default_quadrature_order3D)</code></pre><p>Create a regular P1 tetrahedral grid on a Cuboid in 3D. Does not use Delaunay triangulation internally.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/gridfunctions.jl#L436-L440">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.regularP2TetrahedralGrid" href="#CoherentStructures.regularP2TetrahedralGrid"><code>CoherentStructures.regularP2TetrahedralGrid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">regularP2TetrahedralGrid(numnodes=(10,10,10), LL=[0.0,0.0,0.0], UR=[1.0,1.0,1.0], quadrature_order=default_quadrature_order3D)</code></pre><p>Create a regular P2 tetrahedral grid on a Cuboid in 3D. Does not use Delaunay triangulation internally.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/gridfunctions.jl#L446-L450">source</a></section><p>All of these methods return a <code>gridContext</code> object.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.gridContext" href="#CoherentStructures.gridContext"><code>CoherentStructures.gridContext</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct gridContext&lt;dim&gt;</code></pre><p>Stores everything needed as &quot;context&quot; to be able to work on a FEM grid based on the <code>JuAFEM</code> package. Adds a point-locator API which facilitates plotting functions defined on the grid within Julia.</p><p><strong>Fields</strong></p><ul><li><code>grid::JuAFEM.Grid</code>, <code>ip::JuAFEM.Interpolation</code>, <code>qr::JuAFEM.QuadratureRule</code> - See the <code>JuAFEM</code> package</li><li><code>loc::CellLocator</code> object used for point-location on the grid.</li><li><code>node_to_dof::Vector{Int}</code>  lookup table for dof index of a node</li><li><code>dof_to_node::Vector{Int}</code>  inverse of node<em>to</em>dof</li><li><code>n::Int</code> number of nodes on the grid</li><li><code>m::Int</code> number of elements (e.g. triangles,quadrilaterals, ...) on the grid</li><li><code>quadrature_points::Vector{Vec{dim,Float64}}</code> All quadrature points on the grid, in a fixed order.</li><li><code>mass_weights::Vector{Float64}</code> Weighting for mass matrix</li><li><code>spatialBounds</code> If available, the corners of a bounding box of a domain. For regular grids, the bounds are tight.</li><li><code>numberOfPointsInEachDirection</code> For regular grids, how many (non-interior) nodes make up the regular grid.</li><li><code>gridType</code> A string describing what kind of grid this is (e.g. &quot;regular triangular grid&quot;)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/gridfunctions.jl#L19-L37">source</a></section><h4><a class="nav-anchor" id="Irregular-grids-1" href="#Irregular-grids-1">Irregular grids</a></h4><p>The constructors for <code>CoherentStructures.gridContext</code>, including one for irregular Delaunay grids, are not exported by default, the documentation is available through the REPL:</p><pre><code class="language-" id="TODO">help?&gt; (::Type{CoherentStructures.gridContext{2}})</code></pre><h3><a class="nav-anchor" id="Boundary-Conditions-API-1" href="#Boundary-Conditions-API-1">Boundary Conditions API</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.boundaryData" href="#CoherentStructures.boundaryData"><code>CoherentStructures.boundaryData</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">mutable struct boundaryData</code></pre><p>Represent (a combination of) homogeneous Dirichlet and periodic boundary conditions. Fields:</p><ul><li><code>dbc_dofs</code> list of dofs that should have homogeneous Dirichlet boundary conditions. Must be sorted.</li><li><code>periodic_dofs_from</code> and <code>periodic_dofs_to</code> are both <code>Vector{Int}</code>. The former <em>must</em> be strictly increasing, both must be the same length. <code>periodic_dofs_from[i]</code> is identified with <code>periodic_dofs_to[i]</code>. <code>periodic_dofs_from[i]</code> must be strictly larger than <code>periodic_dofs_to[i]</code>. Multiple dofs can be identified with the same dof. If some dof is identified with another dof and one of them is in <code>dbc_dofs</code>, both points <em>must</em> be in <code>dbc_dofs</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/gridfunctions.jl#L1032-L1039">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.getHomDBCS" href="#CoherentStructures.getHomDBCS"><code>CoherentStructures.getHomDBCS</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getHomDBCS(ctx,which=&quot;all&quot;)</code></pre><p>Return <code>boundaryData</code> object corresponding to homogeneous Dirichlet Boundary Conditions for a set of facesets. <code>which=&quot;all&quot;</code> is shorthand for <code>[&quot;left&quot;,&quot;right&quot;,&quot;top&quot;,&quot;bottom&quot;]</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/gridfunctions.jl#L1057-L1062">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.undoBCS" href="#CoherentStructures.undoBCS"><code>CoherentStructures.undoBCS</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">undoBCS(ctx,u,bdata)</code></pre><p>Given a vector <code>u</code> in dof order with boundary conditions applied, return the corresponding <code>u</code> in dof order without the boundary conditions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/gridfunctions.jl#L1098-L1103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.applyBCS" href="#CoherentStructures.applyBCS"><code>CoherentStructures.applyBCS</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">applyBCS(ctx,K,bdata)</code></pre><p>Apply the boundary conditions from <code>bdata</code> to the <code>ctx.n</code> by <code>ctx.n</code> sparse matrix <code>K</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/gridfunctions.jl#L1217-L1221">source</a></section><h3><a class="nav-anchor" id="Helper-functions-1" href="#Helper-functions-1">Helper functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.dof2node" href="#CoherentStructures.dof2node"><code>CoherentStructures.dof2node</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dof2node(ctx,u)</code></pre><p>Interprets <code>u</code> as an array of coefficients ordered in dof order, and reorders them to be in node order.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/util.jl#L76-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.getDofCoordinates" href="#CoherentStructures.getDofCoordinates"><code>CoherentStructures.getDofCoordinates</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getDofCoordinates(ctx,dofindex)</code></pre><p>Return the coordinates of the node corresponding to the dof with index <code>dofindex</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/gridfunctions.jl#L1122-L1126">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.evaluate_function_from_dofvals" href="#CoherentStructures.evaluate_function_from_dofvals"><code>CoherentStructures.evaluate_function_from_dofvals</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">evaluate_function_from_dofvals(ctx,dofvals,x_in; [outside_value=0,project_in=false])</code></pre><p>Evaluate a function in the approximation space at the point <code>x_in</code>. If <code>x_in</code> is out of points, return <code>outside_value</code>. If <code>project_in</code> is <code>true</code>, points not within <code>ctx.spatialBounds</code> are first projected into the domain.</p><p>The coefficients in <code>nodevals</code> are interpreted to be in dof order.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/gridfunctions.jl#L529-L536">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.evaluate_function_from_nodevals" href="#CoherentStructures.evaluate_function_from_nodevals"><code>CoherentStructures.evaluate_function_from_nodevals</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">evaluate_function_from_nodevals(ctx,nodevals,x_in; [outside_value=0, project_in=false])</code></pre><p>Like <code>evaluate_function_from_dofvals</code>, but the coefficients from <code>nodevals</code> are assumed to be in node order.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/gridfunctions.jl#L480-L484">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.nodal_interpolation" href="#CoherentStructures.nodal_interpolation"><code>CoherentStructures.nodal_interpolation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nodal_interpolation(ctx,f)</code></pre><p>Perform nodal interpolation of a function. Returns a vector of coefficients in dof order</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/gridfunctions.jl#L1023-L1027">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.getH" href="#CoherentStructures.getH"><code>CoherentStructures.getH</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getH(ctx)</code></pre><p>Return the mesh width of a regular grid.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/util.jl#L169-L173">source</a></section><h3><a class="nav-anchor" id="Plotting-API-1" href="#Plotting-API-1">Plotting API</a></h3><h4><a class="nav-anchor" id="FEM-1" href="#FEM-1">FEM</a></h4><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.plot_u" href="#CoherentStructures.plot_u"><code>CoherentStructures.plot_u</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">plot_u(ctx, dof_vals, nx, ny; bdata=nothing, kwargs...)</code></pre><p>Plot the function with coefficients (in dof order, possible boundary conditions in <code>bdata</code>) given by <code>dof_vals</code> on the grid <code>ctx</code>. The domain to be plotted on is given by <code>ctx.spatialBounds</code>. The function is evaluated on a regular <code>nx</code> by <code>ny</code> grid, the resulting plot is a heatmap. Keyword arguments are passed down to <code>plot_u_eulerian</code>, which this function calls internally.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/plotting.jl#L2-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.plot_u_eulerian" href="#CoherentStructures.plot_u_eulerian"><code>CoherentStructures.plot_u_eulerian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">plot_u_eulerian(ctx,dof_vals,inverse_flow_map,
    LL,UR,nx,ny,
    euler_to_lagrange_points=nothing, only_get_lagrange_points=false,
    z=nothing,
    postprocessor=nothing,
    bdata=nothing, ....)</code></pre><p>Plot a heatmap of a function in eulerian coordinates, i.e. the pushforward of <span>$f$</span>. This is given by <span>$f \circ \Phi^{-1}$</span>, <span>$f$</span> is a function defined on the grid <code>ctx</code>, represented by coefficients given by <code>dof_vals</code> (with possible boundary conditions given in <code>bdata</code>)</p><p>The argument <code>inverse_flow_map</code> is <span>$\Phi^{-1}$</span>.</p><p>The resulting plot is on a regular <code>nx</code> by <code>ny</code> grid on the grid with lower left corner <code>LL</code> and upper right corner <code>UR</code>.</p><p>Points that fall outside of the domain represented by <code>ctx</code> are plotted as <code>NaN</code>, which results in transparency.</p><p>One can pass values to be plotted directly by providing them in an array in the argument <code>z</code>. <code>postprocessor</code> can modify the values being plotted, <code>return_scalar_field</code> results in these values being returned.  See the source code for further details.  Additional arguments are passed to <code>Plots.heatmap</code></p><p>Inverse flow maps are computed in parallel if there are multiple workers.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/plotting.jl#L95-L115">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.eulerian_videos" href="#CoherentStructures.eulerian_videos"><code>CoherentStructures.eulerian_videos</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> eulerian_videos(ctx, us, inverse_flow_map_t, t0,tf, nx,ny,nt, LL,UR, num_videos=1;
    extra_kwargs_fun=nothing, ...)</code></pre><p>Create <code>num_videos::Int</code> videos in eulerian coordinates, i.e. where the time <span>$t$</span> is varied, plot <span>$f_i \circ \Phi_t^0$</span> for <span>$f_1, \dots$</span>.</p><p><code>us(i,t)</code> is a vector of dofs to be plotted at time <code>t</code> for the <code>i</code>th video.</p><p><code>inverse_flow_map_t(t,x)</code> is <span>$\Phi_t^0(x)$</span></p><p><code>t0, tf</code>  are initial and final time. Spatial bounds are given by <code>LL,UR</code></p><p><code>nx,ny,nt</code> give the number of points in each direction.</p><p><code>extra_kwargs_fun(i,t)</code> can be used to provide additional keyword arguments to Plots.heatmap()</p><p>Additional kwargs are passed down to <code>plot_eulerian_video</code></p><p>As much as possible is done in parallel.</p><p>Returns a Vector of iterables <code>result</code>. Call <code>Plots.animate(result[i])</code> to get an animation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/plotting.jl#L227-L248">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.eulerian_video" href="#CoherentStructures.eulerian_video"><code>CoherentStructures.eulerian_video</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eulerian_video(ctx, u, inverse_flow_map_t,t0,tf, nx, ny, nt, LL, UR;extra_kwargs_fun=nothing,...)</code></pre><p>Like <code>eulerian_videos</code>, but <code>u(t)</code> is a vector of dofs, and <code>extra_kwargs_fun(t)</code> gives extra keyword arguments. Returns only one result, on which <code>Plots.animate()</code> can be applied.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/plotting.jl#L252-L257">source</a></section><h3><a class="nav-anchor" id="Other-plotting-utilities-1" href="#Other-plotting-utilities-1">Other plotting utilities</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.plot_ftle" href="#CoherentStructures.plot_ftle"><code>CoherentStructures.plot_ftle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">plot_ftle(odefun,p,tspan,LL,UR,nx,ny;
    δ=1e-9,tolerance=1e-4,solver=OrdinaryDiffEq.BS5(),
    existing_plot=nothing,flip_y=false, check_inbounds=always_true)</code></pre><p>Make a heatmap of a FTLE field using finite differences. If <code>existing_plot</code> is given a value, plot using <code>heatmap!</code> on top of it. If <code>flip_y</code> is true, then flip the y-coordinate (needed sometimes due to a bug in Plots). Points where <code>check_inbounds(x[1],x[2],p) == false</code> are set to <code>NaN</code> (i.e. transparent).</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/5f4f63b5a12834196ee823252855a3ed1961edfd/src/plotting.jl#L405-L414">source</a></section><h3><a class="nav-anchor" id="Defaults-1" href="#Defaults-1">Defaults</a></h3><pre><code class="language-none">const default_quadrature_order=5
const default_solver = OrdinaryDiffEq.BS5()</code></pre><footer><hr/><a class="previous" href="basics.html"><span class="direction">Previous</span><span class="title">Basics</span></a><a class="next" href="elliptic.html"><span class="direction">Next</span><span class="title">Geodesic vortices</span></a></footer></article></body></html>
