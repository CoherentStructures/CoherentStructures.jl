<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Geodesic vortices · CoherentStructures.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CoherentStructures.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/">Examples</a></li><li><a class="toctext" href="../generated/rot_double_gyre/">Rotating double gyre</a></li><li><a class="toctext" href="../generated/standard_map/">Standard map</a></li><li><a class="toctext" href="../generated/bickley/">Bickley jet</a></li><li><a class="toctext" href="../generated/ocean_flow/">Geostrophic ocean flow</a></li><li><a class="toctext" href="../generated/trajectories/">Working with trajectories</a></li></ul></li><li><a class="toctext" href="../basics/">Basics</a></li><li><span class="toctext">Methods</span><ul><li><a class="toctext" href="../fem/">FEM-based methods</a></li><li class="current"><a class="toctext" href>Geodesic vortices</a><ul class="internal"><li><a class="toctext" href="#Background-1">Background</a></li><li><a class="toctext" href="#Function-documentation-1">Function documentation</a></li></ul></li><li><a class="toctext" href="../Laplace/">Graph Laplacian-based methods</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Methods</li><li><a href>Geodesic vortices</a></li></ul><a class="edit-page" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/master/docs/src/elliptic.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Geodesic vortices</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Geodesic-elliptic-material-vortices-1" href="#Geodesic-elliptic-material-vortices-1">Geodesic elliptic material vortices</a></h1><h2><a class="nav-anchor" id="Background-1" href="#Background-1">Background</a></h2><p>The following functions implement an LCS methodology developed in the following papers:</p><ul><li><a href="https://dx.doi.org/10.1016/j.physd.2012.06.012">Haller &amp; Beron-Vera, 2012</a></li><li><a href="https://dx.doi.org/10.1017/jfm.2013.391">Haller &amp; Beron-Vera, 2013</a></li><li><a href="https://dx.doi.org/10.1098/rspa.2014.0639">Karrasch, Huhn, and Haller, 2015</a></li></ul><p>Our implementation here follows conceptually <a href="https://dx.doi.org/10.1098/rspa.2014.0639">Karrasch, Huhn, and Haller, 2015</a>, and is described in detail in the preprint TBD. Depending on the indefinite metric tensor field used, the functions below yield the following types of coherent structures:</p><ul><li>black-hole/Lagrangian coherent vortices (<a href="https://doi.org/10.1017/jfm.2013.391">Haller &amp; Beron-Vera, 2012</a>)</li><li>elliptic objective Eulerian coherent structures (OECSs) (<a href="https://dx.doi.org/10.1063/1.4951720">Serra &amp; Haller, 2016</a>)</li><li>material diffusive transport barriers (<a href="https://doi.org/10.1073/pnas.1720177115">Haller, Karrasch, and Kogelbauer, 2018</a>)</li></ul><p>The general procedure is the following. Assume <span>$T$</span> is the symmetric tensor field of interest, say, (i) the Cauchy-Green strain tensor field <span>$C$</span>, (ii) the rate-of-strain tensor field <span>$S$</span>, or (iii) the averaged diffusion-weighted Cauchy-Green tensor field <span>$\bar{C}_D$</span>; cf. the references above. Denote by <span>$0&lt;\lambda_1\leq\lambda_2$</span> the eigenvalue and by <span>$\xi_1$</span> and <span>$\xi_2$</span> the corresponding eigenvector fields of <span>$T$</span>. Then the direction fields of interest are given by</p><div>\[\eta_{\lambda}^{\pm} := \sqrt{\frac{\lambda_2 - \lambda}{\lambda_2-\lambda_1}}\xi_1 \pm \sqrt{\frac{\lambda - \lambda_1}{\lambda_2-\lambda_1}}\xi_2.\]</div><p>Tensor singularities are defined as points at which <span>$\lambda_2=\lambda_1$</span>, i.e., at which the two characteristic directions <span>$\xi_1$</span> and <span>$\xi_2$</span> are not well-defined. As described and exploited in <a href="https://dx.doi.org/10.1098/rspa.2014.0639">Karrasch et al., 2015</a>, non-negligible tensor singularities express themselves by an angle gap when tracking (the angle of) tensor eigenvector fields along closed paths surrounding the singularity. Our approach here avoids computing singularities directly, but rather computes the index for each grid cell and then combines nearby singularities, i.e., adds non-vanishing indices of nearby grid cells.</p><p>In summary, the implementation consists of the following steps:</p><ol><li>compute the index for each grid cell and combine nearby singular grid cells to &quot;singularity candidates&quot;;</li><li>look for elliptic singularity candidates (and potentially isolated wedge pairs);</li><li>place an eastwards oriented Poincaré section at the pair center;</li><li>for each point on the discretized Poincaré section, scan through the given parameter interval such that the corresponding η-orbit closes at that point;</li><li>if desired: for each Poincaré section, take the outermost closed orbit as the coherent vortex barrier (if there exist any).</li></ol><h2><a class="nav-anchor" id="Function-documentation-1" href="#Function-documentation-1">Function documentation</a></h2><h3><a class="nav-anchor" id="The-meta-functions-ellipticLCS-and-constrainedLCS-1" href="#The-meta-functions-ellipticLCS-and-constrainedLCS-1">The meta-functions <code>ellipticLCS</code> and <code>constrainedLCS</code></a></h3><p>The fully automated high-level functions are:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.ellipticLCS" href="#CoherentStructures.ellipticLCS"><code>CoherentStructures.ellipticLCS</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ellipticLCS(T::AbstractArray, xspan, yspan, p; kwargs...)
ellipticLCS(T::AxisArray, p; kwargs...)</code></pre><p>Computes elliptic LCSs as null-geodesics of the Lorentzian metric tensor field given by shifted versions of <code>T</code> on the 2D computational grid spanned by <code>xspan</code> and <code>yspan</code>. <code>p</code> is a <a href="#CoherentStructures.LCSParameters"><code>LCSParameters</code></a>-type container of computational parameters. Returns a list of <code>EllipticBarrier</code>-type objects.</p><p>The keyword arguments and their default values are:</p><ul><li><code>outermost=true</code>: only the outermost barriers, i.e., the vortex   boundaries are returned, otherwise all detected transport barrieres;</li><li><code>verbose=true</code>: show intermediate computational information;</li><li><code>debug=false</code>: whether to use the debug mode, which avoids parallelization   for more precise error messages.</li><li><code>singularity_predicate = nothing</code>: provide an optional callback to reject certain singularity candidates.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/76c1251cd04eeaaeb08bb335d28eb91bda2742de/src/ellipticLCS.jl#L565-L581">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.constrainedLCS" href="#CoherentStructures.constrainedLCS"><code>CoherentStructures.constrainedLCS</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">constrainedLCS(T::AbstractArray, xspan, yspan, p; kwargs...)
constrainedLCS(T::AxisArray, p; kwargs...)</code></pre><p>Computes constrained transport barriers as closed orbits of the transport vector field on the 2D computational grid spanned by <code>xspan</code> and <code>yspan</code>. <code>p</code> is an <a href="#CoherentStructures.LCSParameters"><code>LCSParameters</code></a>-type container of computational parameters. Returns a list of <code>EllipticBarrier</code>-type objects.</p><p>The keyword arguments and their default values are:</p><ul><li><code>outermost=true</code>: only the outermost barriers, i.e., the vortex   boundaries are returned, otherwise all detected transport barrieres;</li><li><code>verbose=true</code>: show intermediate computational information</li><li><code>debug=false</code>: whether to use the debug mode, which avoids parallelization   for more precise error messages.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/76c1251cd04eeaaeb08bb335d28eb91bda2742de/src/ellipticLCS.jl#L766-L781">source</a></section><p>One of their arguments is a list of parameters used in the LCS detection. This list is combined in a data type called <code>LCSParameters</code>. The output is a list of <code>EllipticBarrier</code>s and a list of <code>Singularity</code>s. There is an option to retrieve all closed barriers (<code>outermost=false</code>), in contrast to extracting only the outermost vortex boundaries (<code>outermost=true</code>), which is more efficient.</p><p>The meta-functions consist of two steps: first, the index theory-based determination of where to search for closed orbits,, cf. <a href="#Index-theory-based-placement-of-Poincaré-sections-1">Index theory-based placement of Poincaré sections</a>; second, the closed orbit computation, cf. <a href="#Closed-orbit-detection-1">Closed orbit detection</a>.</p><h3><a class="nav-anchor" id="Specific-types-1" href="#Specific-types-1">Specific types</a></h3><p>These are the specifically introduced types for elliptic LCS computations.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.LCSParameters" href="#CoherentStructures.LCSParameters"><code>CoherentStructures.LCSParameters</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Container for parameters used in elliptic LCS computations.</p><p><strong>Fields</strong></p><ul><li><code>boxradius</code>: &quot;radius&quot; of localization square for closed orbit detection</li><li><code>indexradius=1e-1boxradius</code>: radius for singularity type detection</li><li><code>combine_pairs=true</code>: whether isolated singularity pairs should be merged</li><li><code>n_seeds=100</code>: number of seed points on the Poincaré section</li><li><code>pmin=0.7</code>: lower bound on the parameter in the <span>$\eta$</span>-field</li><li><code>pmax=2.0</code>: upper bound on the parameter in the <span>$\eta$</span>-field</li><li><code>rdist=1e-4boxradius</code>: required return distances for closed orbits</li><li><code>tolerance_ode=1e-8boxradius</code>: absolute and relative tolerance in orbit integration</li><li><code>maxiters_ode::Int=2000</code>: maximum number of integration steps</li><li><code>max_orbit_length=8boxradius</code>: maximum length of orbit length</li><li><code>maxiters_bisection::Int=20</code>: maximum steps in bisection procedure</li><li><code>only_enclosing::Bool=true</code>: whether the orbit must enclose the starting point of the Poincaré section</li><li><code>only_smooth::Bool=true</code>: whether or not to reject orbits with &quot;corners&quot;.</li><li><code>only_uniform::Bool=true</code>: whether or not to reject orbits that are not uniform</li></ul><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; p = LCSParameters(2.5)
LCSParameters(2.5, 0.25, true, 100, 0.7, 2.0, 0.00025, 2.5e-8, 1000, 20.0, 30)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/76c1251cd04eeaaeb08bb335d28eb91bda2742de/src/ellipticLCS.jl#L73-L97">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.EllipticBarrier" href="#CoherentStructures.EllipticBarrier"><code>CoherentStructures.EllipticBarrier</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>This is a container for coherent vortex boundaries. An object <code>vortex</code> of type <code>EllipticBarrier</code> can be easily plotted by <code>plot(vortex.curve)</code>, or <code>plot!([figure, ]vortex.curve)</code> if it is to be overlaid over an existing plot.</p><p><strong>Fields</strong></p><ul><li><code>curve</code>: a vector of tuples, contains the coordinates of coherent vortex boundary points;</li><li><code>core</code>: location of the vortex core;</li><li><code>p</code>: contains the parameter value of the direction field <span>$\eta_{\lambda}^{\pm}$</span>, for which the <code>curve</code> is a closed orbit;</li><li><code>s</code>: a <code>Bool</code> value, which encodes the sign in the formula of the direction field <span>$\eta_{\lambda}^{\pm}$</span> via the formula <span>$(-1)^s$</span>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/76c1251cd04eeaaeb08bb335d28eb91bda2742de/src/ellipticLCS.jl#L39-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.EllipticVortex" href="#CoherentStructures.EllipticVortex"><code>CoherentStructures.EllipticVortex</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>This is a container for an elliptic vortex, as represented by the vortex&#39;s <code>center</code> and a list <code>barriers</code> of all computed <a href="#CoherentStructures.EllipticBarrier"><code>EllipticBarrier</code></a>s.</p><p><strong>Fields</strong></p><ul><li><code>center</code>: location of the vortex center;</li><li><code>barriers</code>: vector of <code>EllipticBarrier</code>s.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/76c1251cd04eeaaeb08bb335d28eb91bda2742de/src/ellipticLCS.jl#L60-L67">source</a></section><p>Another one is <code>Singularity</code>, which comes along with some convenience functions.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.Singularity" href="#CoherentStructures.Singularity"><code>CoherentStructures.Singularity</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Container type for critical points of vector fields or singularities of line fields.</p><p><strong>Fields</strong></p><ul><li><code>coords::SVector{2}</code>: coordinates of the singularity</li><li><code>index::Rational</code>: index of the singularity</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/76c1251cd04eeaaeb08bb335d28eb91bda2742de/src/ellipticLCS.jl#L3-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.getcoords" href="#CoherentStructures.getcoords"><code>CoherentStructures.getcoords</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getcoords(singularities)</code></pre><p>Extracts the coordinates of <code>singularities</code>, a vector of <code>Singularity</code>s. Returns a vector of <code>SVector</code>s.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/76c1251cd04eeaaeb08bb335d28eb91bda2742de/src/ellipticLCS.jl#L22-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.getindices" href="#CoherentStructures.getindices"><code>CoherentStructures.getindices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getindices(singularities)</code></pre><p>Extracts the indices of <code>singularities</code>, a vector of <code>Singularity</code>s.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/76c1251cd04eeaaeb08bb335d28eb91bda2742de/src/ellipticLCS.jl#L31-L34">source</a></section><h3><a class="nav-anchor" id="Index-theory-based-placement-of-Poincaré-sections-1" href="#Index-theory-based-placement-of-Poincaré-sections-1">Index theory-based placement of Poincaré sections</a></h3><p>This is performed by <a href="#CoherentStructures.singularity_detection"><code>singularity_detection</code></a> for line fields (such as eigenvector fields of symmetric positive-definite tensor fields) and by <a href="#CoherentStructures.critical_point_detection"><code>critical_point_detection</code></a> for classic vector fields.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.singularity_detection" href="#CoherentStructures.singularity_detection"><code>CoherentStructures.singularity_detection</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">singularity_detection(T, combine_distance; combine_isolated_wedges=true) -&gt; Vector{Singularity}</code></pre><p>Calculates line-field singularities of the first eigenvector of <code>T</code> by taking a discrete differential-geometric approach. Singularities are calculated on each cell. Singularities with distance less or equal to <code>combine_distance</code> are combined by averaging the coordinates and adding the respective indices. If <code>combine_pairs</code> is <code>true</code>, pairs of singularities that are mutually closest to each other are included in the final list.</p><p>Returns a vector of <a href="#CoherentStructures.Singularity"><code>Singularity</code></a>s.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/76c1251cd04eeaaeb08bb335d28eb91bda2742de/src/ellipticLCS.jl#L369-L380">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.critical_point_detection" href="#CoherentStructures.critical_point_detection"><code>CoherentStructures.critical_point_detection</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">critical_point_detection(vs, combine_distance, dist=s1dist; combine_pairs=true) -&gt; Vector{Singularity}</code></pre><p>Computes critical points of a vector/line field <code>vs</code>, given as an <code>AxisArray</code>. Critical points with distance less or equal to <code>combine_distance</code> are combined by averaging the coordinates and adding the respective indices. The argument <code>dist</code> is a signed distance function for angles: choose <a href="#CoherentStructures.s1dist"><code>s1dist</code></a> for vector fields, and <a href="#CoherentStructures.p1dist"><code>p1dist</code></a> for line fields; cf. <a href="#CoherentStructures.compute_singularities"><code>compute_singularities</code></a>. If <code>combine_pairs is</code>true, pairs of singularities that are mutually the closest ones are included in the final list.</p><p>Returns a vector of <a href="#CoherentStructures.Singularity"><code>Singularity</code></a>s.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/76c1251cd04eeaaeb08bb335d28eb91bda2742de/src/ellipticLCS.jl#L341-L353">source</a></section><p>This function takes three steps.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.compute_singularities" href="#CoherentStructures.compute_singularities"><code>CoherentStructures.compute_singularities</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">compute_singularities(v, dist=s1dist) -&gt; Vector{Singularity}</code></pre><p>Computes critical points and singularities of vector and line fields <code>v</code>, respectively. The argument <code>dist</code> is a signed distance function for angles. Choose <code>s1dist</code> (default) for vector fields, and <code>p1dist</code> for line fields.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/76c1251cd04eeaaeb08bb335d28eb91bda2742de/src/ellipticLCS.jl#L201-L207">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.combine_singularities" href="#CoherentStructures.combine_singularities"><code>CoherentStructures.combine_singularities</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">combine_singularities(sing_coordinates, sing_indices, combine_distance) -&gt; Vector{Singularity}</code></pre><p>This function does the equivalent of: Build a graph where singularities are vertices, and two vertices share an edge iff the coordinates of the corresponding vertices (given by <code>sing_coordinates</code>) have a distance leq <code>combine_distance</code>. Find all connected components of this graph, and return a list of their mean coordinate and sum of <code>sing_indices</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/76c1251cd04eeaaeb08bb335d28eb91bda2742de/src/ellipticLCS.jl#L229-L237">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.combine_isolated_wedges" href="#CoherentStructures.combine_isolated_wedges"><code>CoherentStructures.combine_isolated_wedges</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">combine_isolated_wedges(singularities)</code></pre><p>Determines singularities which are mutually closest neighbors and combines them as one, while adding their indices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/76c1251cd04eeaaeb08bb335d28eb91bda2742de/src/ellipticLCS.jl#L292-L297">source</a></section><p>The function <a href="#CoherentStructures.compute_singularities"><code>compute_singularities</code></a> requires one of two signed distance functions for angles. These are <a href="#CoherentStructures.s1dist"><code>s1dist</code></a> for vector fields, and <a href="#CoherentStructures.p1dist"><code>p1dist</code></a> for line fields.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.s1dist" href="#CoherentStructures.s1dist"><code>CoherentStructures.s1dist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">s1dist(α, β)</code></pre><p>Computes the signed length of the angle of the shortest circle segment going from angle <code>β</code> to angle <code>α</code>, as computed on the full circle.</p><p><strong>Examples</strong></p><p>```jldoctest julia&gt; s1dist(π/2, 0) 1.5707963267948966</p><p>julia&gt; s1dist(0, π/2) -1.5707963267948966</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/76c1251cd04eeaaeb08bb335d28eb91bda2742de/src/ellipticLCS.jl#L171-L184">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.p1dist" href="#CoherentStructures.p1dist"><code>CoherentStructures.p1dist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">p1dist(α, β)</code></pre><p>Computes the signed length of the angle of the shortest circle segment going from angle <code>β</code> to angle <code>α [± π]</code>, as computed on the half circle.</p><p><strong>Examples</strong></p><p>```jldoctest julia&gt; p1dist(π, 0) 0.0</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/76c1251cd04eeaaeb08bb335d28eb91bda2742de/src/ellipticLCS.jl#L187-L197">source</a></section><p>From all virtual/merged singularities those with a suitable index are selected. Around each elliptic singularity the tensor field is localized and passed on for closed orbit detection.</p><h3><a class="nav-anchor" id="Closed-orbit-detection-1" href="#Closed-orbit-detection-1">Closed orbit detection</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.compute_returning_orbit" href="#CoherentStructures.compute_returning_orbit"><code>CoherentStructures.compute_returning_orbit</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">compute_returning_orbit(vf, seed::SVector{2}, save::Bool=false, maxiters=2000, tolerance=1e-8, max_orbit_length=20.0)</code></pre><p>Computes returning orbits under the velocity field <code>vf</code>, originating from <code>seed</code>. The optional argument <code>save</code> controls whether intermediate locations of the returning orbit should be saved. Returns a tuple of <code>orbit</code> and <code>statuscode</code> (<code>0</code> for success, <code>1</code> for <code>maxiters</code> reached, <code>2</code> for out of bounds error, 3 for other error).</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/76c1251cd04eeaaeb08bb335d28eb91bda2742de/src/ellipticLCS.jl#L389-L397">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.compute_closed_orbits" href="#CoherentStructures.compute_closed_orbits"><code>CoherentStructures.compute_closed_orbits</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">compute_closed_orbits(ps, ηfield, cache; rev=true, pmin=0.7, pmax=1.5, rdist=1e-4, tolerance_ode=1e-8, maxiters_ode=2000, maxiters_bisection=20)</code></pre><p>Compute the (outermost) closed orbit for a given Poincaré section <code>ps</code>, a vector field constructor <code>ηfield</code>, and an LCScache <code>cache</code>. Keyword arguments <code>pmin</code> and <code>pmax</code> correspond to the range of shift parameters in which closed orbits are sought; <code>rev</code> determines whether closed orbits are sought from the outside inwards (<code>true</code>) or from the inside outwards (<code>false</code>). <code>rdist</code> sets the required return distance for an orbit to be considered as closed. The parameter <code>maxiters_ode</code> gives the maximum number of steps taken by the ODE solver when computing the closed orbit, the ode solver uses tolerance given by <code>tolerance_ode</code>. The parameter <code>maxiters_bisection</code> gives the maximum number of iterations used by the bisection algorithm to find closed orbits.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/76c1251cd04eeaaeb08bb335d28eb91bda2742de/src/ellipticLCS.jl#L457-L469">source</a></section><footer><hr/><a class="previous" href="../fem/"><span class="direction">Previous</span><span class="title">FEM-based methods</span></a><a class="next" href="../Laplace/"><span class="direction">Next</span><span class="title">Graph Laplacian-based methods</span></a></footer></article></body></html>
