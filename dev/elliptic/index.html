<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Geodesic vortices · CoherentStructures.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CoherentStructures.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/rot_double_gyre/">Rotating double gyre</a></li><li><a class="tocitem" href="../generated/standard_map/">Standard map</a></li><li><a class="tocitem" href="../generated/bickley/">Bickley jet</a></li><li><a class="tocitem" href="../generated/ocean_flow/">Geostrophic ocean flow</a></li><li><a class="tocitem" href="../generated/trajectories/">Working with trajectories</a></li></ul></li><li><a class="tocitem" href="../basics/">Basics</a></li><li><span class="tocitem">Methods</span><ul><li><a class="tocitem" href="../fem/">FEM-based methods</a></li><li class="is-active"><a class="tocitem" href>Geodesic vortices</a><ul class="internal"><li><a class="tocitem" href="#Background-1"><span>Background</span></a></li><li><a class="tocitem" href="#Function-documentation-1"><span>Function documentation</span></a></li></ul></li><li><a class="tocitem" href="../Laplace/">Graph Laplacian-based methods</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Methods</a></li><li class="is-active"><a href>Geodesic vortices</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Geodesic vortices</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/master/docs/src/elliptic.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Geodesic-elliptic-material-vortices-1"><a class="docs-heading-anchor" href="#Geodesic-elliptic-material-vortices-1">Geodesic elliptic material vortices</a><a class="docs-heading-anchor-permalink" href="#Geodesic-elliptic-material-vortices-1" title="Permalink"></a></h1><h2 id="Background-1"><a class="docs-heading-anchor" href="#Background-1">Background</a><a class="docs-heading-anchor-permalink" href="#Background-1" title="Permalink"></a></h2><p>The following functions implement an LCS methodology developed in the following papers:</p><ul><li><a href="https://dx.doi.org/10.1016/j.physd.2012.06.012">Haller &amp; Beron-Vera, 2012</a></li><li><a href="https://dx.doi.org/10.1017/jfm.2013.391">Haller &amp; Beron-Vera, 2013</a></li><li><a href="https://dx.doi.org/10.1098/rspa.2014.0639">Karrasch, Huhn, and Haller, 2015</a></li></ul><p>Our implementation here follows conceptually <a href="https://dx.doi.org/10.1098/rspa.2014.0639">Karrasch, Huhn, and Haller, 2015</a>, and is described in detail in the preprint TBD. Depending on the indefinite metric tensor field used, the functions below yield the following types of coherent structures:</p><ul><li>black-hole/Lagrangian coherent vortices (<a href="https://doi.org/10.1017/jfm.2013.391">Haller &amp; Beron-Vera, 2012</a>)</li><li>elliptic objective Eulerian coherent structures (OECSs) (<a href="https://dx.doi.org/10.1063/1.4951720">Serra &amp; Haller, 2016</a>)</li><li>material diffusive transport barriers (<a href="https://doi.org/10.1073/pnas.1720177115">Haller, Karrasch, and Kogelbauer, 2018</a>)</li></ul><p>The general procedure is the following. Assume <span>$T$</span> is the symmetric tensor field of interest, say, (i) the Cauchy-Green strain tensor field <span>$C$</span>, (ii) the rate-of-strain tensor field <span>$S$</span>, or (iii) the averaged diffusion-weighted Cauchy-Green tensor field <span>$\bar{C}_D$</span>; cf. the references above. Denote by <span>$0&lt;\lambda_1\leq\lambda_2$</span> the eigenvalue and by <span>$\xi_1$</span> and <span>$\xi_2$</span> the corresponding eigenvector fields of <span>$T$</span>. Then the direction fields of interest are given by</p><div>\[\eta_{\lambda}^{\pm} := \sqrt{\frac{\lambda_2 - \lambda}{\lambda_2-\lambda_1}}\xi_1 \pm \sqrt{\frac{\lambda - \lambda_1}{\lambda_2-\lambda_1}}\xi_2.\]</div><p>Tensor singularities are defined as points at which <span>$\lambda_2=\lambda_1$</span>, i.e., at which the two characteristic directions <span>$\xi_1$</span> and <span>$\xi_2$</span> are not well-defined. As described and exploited in <a href="https://dx.doi.org/10.1098/rspa.2014.0639">Karrasch et al., 2015</a>, non-negligible tensor singularities express themselves by an angle gap when tracking (the angle of) tensor eigenvector fields along closed paths surrounding the singularity. Our approach here avoids computing singularities directly, but rather computes the index for each grid cell and then combines nearby singularities, i.e., adds non-vanishing indices of nearby grid cells.</p><p>In summary, the implementation consists of the following steps:</p><ol><li>compute the index for each grid cell and combine nearby singular grid cells to &quot;singularity candidates&quot;;</li><li>look for elliptic singularity candidates (and potentially isolated wedge pairs);</li><li>place an eastwards oriented Poincaré section at the pair center;</li><li>for each point on the discretized Poincaré section, scan through the given parameter interval such that the corresponding η-orbit closes at that point;</li><li>if desired: for each Poincaré section, take the outermost closed orbit as the coherent vortex barrier (if there exist any).</li></ol><h2 id="Function-documentation-1"><a class="docs-heading-anchor" href="#Function-documentation-1">Function documentation</a><a class="docs-heading-anchor-permalink" href="#Function-documentation-1" title="Permalink"></a></h2><h3 id="The-meta-functions-ellipticLCS-and-constrainedLCS-1"><a class="docs-heading-anchor" href="#The-meta-functions-ellipticLCS-and-constrainedLCS-1">The meta-functions <code>ellipticLCS</code> and <code>constrainedLCS</code></a><a class="docs-heading-anchor-permalink" href="#The-meta-functions-ellipticLCS-and-constrainedLCS-1" title="Permalink"></a></h3><p>The fully automated high-level functions are:</p><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.ellipticLCS" href="#CoherentStructures.ellipticLCS"><code>CoherentStructures.ellipticLCS</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ellipticLCS(T::AbstractArray, xspan, yspan, p; kwargs...)
ellipticLCS(T::AxisArray, p; kwargs...)</code></pre><p>Computes elliptic LCSs as null-geodesics of the Lorentzian metric tensor field given by shifted versions of <code>T</code> on the 2D computational grid spanned by <code>xspan</code> and <code>yspan</code>. <code>p</code> is a <a href="#CoherentStructures.LCSParameters"><code>LCSParameters</code></a>-type container of computational parameters. Returns a list of <code>EllipticBarrier</code>-type objects.</p><p>The keyword arguments and their default values are:</p><ul><li><code>outermost=true</code>: only the outermost barriers, i.e., the vortex   boundaries are returned, otherwise all detected transport barrieres;</li><li><code>verbose=true</code>: show intermediate computational information;</li><li><code>debug=false</code>: whether to use the debug mode, which avoids parallelization   for more precise error messages.</li><li><code>singularity_predicate = nothing</code>: provide an optional callback to reject certain singularity candidates.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/4515e41931bb0ba163b20c3fa42753bd17c15141/src/ellipticLCS.jl#L706-L722">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.constrainedLCS" href="#CoherentStructures.constrainedLCS"><code>CoherentStructures.constrainedLCS</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">constrainedLCS(T::AbstractArray, xspan, yspan, p; kwargs...)
constrainedLCS(T::AxisArray, p; kwargs...)</code></pre><p>Computes constrained transport barriers as closed orbits of the transport vector field on the 2D computational grid spanned by <code>xspan</code> and <code>yspan</code>. <code>p</code> is an <a href="#CoherentStructures.LCSParameters"><code>LCSParameters</code></a>-type container of computational parameters. Returns a list of <code>EllipticBarrier</code>-type objects.</p><p>The keyword arguments and their default values are:</p><ul><li><code>outermost=true</code>: only the outermost barriers, i.e., the vortex   boundaries are returned, otherwise all detected transport barrieres;</li><li><code>verbose=true</code>: show intermediate computational information</li><li><code>debug=false</code>: whether to use the debug mode, which avoids parallelization   for more precise error messages.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/4515e41931bb0ba163b20c3fa42753bd17c15141/src/ellipticLCS.jl#L997-L1012">source</a></section></article><p>One of their arguments is a list of parameters used in the LCS detection. This list is combined in a data type called <code>LCSParameters</code>. The output is a list of <code>EllipticBarrier</code>s and a list of <code>Singularity</code>s. There is an option to retrieve all closed barriers (<code>outermost=false</code>), in contrast to extracting only the outermost vortex boundaries (<code>outermost=true</code>), which is more efficient.</p><p>The meta-functions consist of two steps: first, the index theory-based determination of where to search for closed orbits,, cf. <a href="#Index-theory-based-placement-of-Poincaré-sections-1">Index theory-based placement of Poincaré sections</a>; second, the closed orbit computation, cf. <a href="#Closed-orbit-detection-1">Closed orbit detection</a>.</p><h3 id="Specific-types-1"><a class="docs-heading-anchor" href="#Specific-types-1">Specific types</a><a class="docs-heading-anchor-permalink" href="#Specific-types-1" title="Permalink"></a></h3><p>These are the specifically introduced types for elliptic LCS computations.</p><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.LCSParameters" href="#CoherentStructures.LCSParameters"><code>CoherentStructures.LCSParameters</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Container for parameters used in elliptic LCS computations.</p><p><strong>Fields</strong></p><ul><li><code>boxradius</code>: &quot;radius&quot; of localization square for closed orbit detection</li><li><code>indexradius=1e-1boxradius</code>: radius for singularity type detection</li><li><code>merge_heuristics</code>: a list of heuristics for combining singularities, supported are</li><li><ul><li><code>combine_20</code>: merge isolated singularity pairs that are mutually nearest neighbors</li></ul></li><li><ul><li><code>combine_31</code>: merge 1 trisector + nearest-neighbor 3 wedge configurations.</li></ul></li><li><ul><li><code>combine_20_aggressive</code>: an additional wedge combination heuristic</li></ul></li><li><code>n_seeds=100</code>: number of seed points on the Poincaré section</li><li><code>pmin=0.7</code>: lower bound on the parameter in the <span>$\eta$</span>-field</li><li><code>pmax=2.0</code>: upper bound on the parameter in the <span>$\eta$</span>-field</li><li><code>rdist=1e-4boxradius</code>: required return distances for closed orbits</li><li><code>tolerance_ode=1e-8boxradius</code>: absolute and relative tolerance in orbit integration</li><li><code>maxiters_ode::Int=2000</code>: maximum number of integration steps</li><li><code>max_orbit_length=8boxradius</code>: maximum length of orbit length</li><li><code>maxiters_bisection::Int=20</code>: maximum steps in bisection procedure</li><li><code>only_enclosing::Bool=true</code>: whether the orbit must enclose the starting point of the Poincaré section</li><li><code>only_smooth::Bool=true</code>: whether or not to reject orbits with &quot;corners&quot;.</li><li><code>only_uniform::Bool=true</code>: whether or not to reject orbits that are not uniform</li></ul><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; p = LCSParameters(2.5)
LCSParameters(2.5, 0.25, true, 100, 0.7, 2.0, 0.00025, 2.5e-8, 1000, 20.0, 30)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/4515e41931bb0ba163b20c3fa42753bd17c15141/src/ellipticLCS.jl#L73-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.EllipticBarrier" href="#CoherentStructures.EllipticBarrier"><code>CoherentStructures.EllipticBarrier</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This is a container for coherent vortex boundaries. An object <code>vortex</code> of type <code>EllipticBarrier</code> can be easily plotted by <code>plot(vortex.curve)</code>, or <code>plot!([figure, ]vortex.curve)</code> if it is to be overlaid over an existing plot.</p><p><strong>Fields</strong></p><ul><li><code>curve</code>: a vector of tuples, contains the coordinates of coherent vortex boundary points;</li><li><code>core</code>: location of the vortex core;</li><li><code>p</code>: contains the parameter value of the direction field <span>$\eta_{\lambda}^{\pm}$</span>, for which the <code>curve</code> is a closed orbit;</li><li><code>s</code>: a <code>Bool</code> value, which encodes the sign in the formula of the direction field <span>$\eta_{\lambda}^{\pm}$</span> via the formula <span>$(-1)^s$</span>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/4515e41931bb0ba163b20c3fa42753bd17c15141/src/ellipticLCS.jl#L39-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.EllipticVortex" href="#CoherentStructures.EllipticVortex"><code>CoherentStructures.EllipticVortex</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This is a container for an elliptic vortex, as represented by the vortex&#39;s <code>center</code> and a list <code>barriers</code> of all computed <a href="#CoherentStructures.EllipticBarrier"><code>EllipticBarrier</code></a>s.</p><p><strong>Fields</strong></p><ul><li><code>center</code>: location of the vortex center;</li><li><code>barriers</code>: vector of <code>EllipticBarrier</code>s.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/4515e41931bb0ba163b20c3fa42753bd17c15141/src/ellipticLCS.jl#L60-L67">source</a></section></article><p>Another one is <code>Singularity</code>, which comes along with some convenience functions.</p><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.Singularity" href="#CoherentStructures.Singularity"><code>CoherentStructures.Singularity</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Container type for critical points of vector fields or singularities of line fields.</p><p><strong>Fields</strong></p><ul><li><code>coords::SVector{2}</code>: coordinates of the singularity</li><li><code>index::Rational</code>: index of the singularity</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/4515e41931bb0ba163b20c3fa42753bd17c15141/src/ellipticLCS.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.getcoords" href="#CoherentStructures.getcoords"><code>CoherentStructures.getcoords</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getcoords(singularities)</code></pre><p>Extracts the coordinates of <code>singularities</code>, a vector of <code>Singularity</code>s. Returns a vector of <code>SVector</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/4515e41931bb0ba163b20c3fa42753bd17c15141/src/ellipticLCS.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.getindices" href="#CoherentStructures.getindices"><code>CoherentStructures.getindices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getindices(singularities)</code></pre><p>Extracts the indices of <code>singularities</code>, a vector of <code>Singularity</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/4515e41931bb0ba163b20c3fa42753bd17c15141/src/ellipticLCS.jl#L31-L34">source</a></section></article><h3 id="Index-theory-based-placement-of-Poincaré-sections-1"><a class="docs-heading-anchor" href="#Index-theory-based-placement-of-Poincaré-sections-1">Index theory-based placement of Poincaré sections</a><a class="docs-heading-anchor-permalink" href="#Index-theory-based-placement-of-Poincaré-sections-1" title="Permalink"></a></h3><p>This is performed by <a href="#CoherentStructures.singularity_detection"><code>singularity_detection</code></a> for line fields (such as eigenvector fields of symmetric positive-definite tensor fields) and by <a href="#CoherentStructures.critical_point_detection"><code>critical_point_detection</code></a> for classic vector fields.</p><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.singularity_detection" href="#CoherentStructures.singularity_detection"><code>CoherentStructures.singularity_detection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">singularity_detection(T, combine_distance; merge_heuristics=[combine_20]) -&gt; Vector{Singularity}</code></pre><p>Calculates line-field singularities of the first eigenvector of <code>T</code> by taking a discrete differential-geometric approach. Singularities are calculated on each cell. Singularities with distance less or equal to <code>combine_distance</code> are combined by averaging the coordinates and adding the respective indices. The heuristics listed in <code>merge_heuristics</code> are used to merge singularities, cf. <a href="#CoherentStructures.LCSParameters"><code>LCSParameters</code></a>.</p><p>Returns a vector of <a href="#CoherentStructures.Singularity"><code>Singularity</code></a>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/4515e41931bb0ba163b20c3fa42753bd17c15141/src/ellipticLCS.jl#L510-L521">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.critical_point_detection" href="#CoherentStructures.critical_point_detection"><code>CoherentStructures.critical_point_detection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">critical_point_detection(vs, combine_distance, dist=s1dist; merge_heuristics=[combine_20]) -&gt; Vector{Singularity}</code></pre><p>Computes critical points of a vector/line field <code>vs</code>, given as an <code>AxisArray</code>. Critical points with distance less or equal to <code>combine_distance</code> are combined by averaging the coordinates and adding the respective indices. The argument <code>dist</code> is a signed distance function for angles: choose <a href="#CoherentStructures.s1dist"><code>s1dist</code></a> for vector fields, and <a href="#CoherentStructures.p1dist"><code>p1dist</code></a> for line fields; cf. <a href="#CoherentStructures.compute_singularities"><code>compute_singularities</code></a>. Heuristics listed as functions in <code>merge_heuristics</code>, cf. <a href="#CoherentStructures.LCSParameters"><code>LCSParameters</code></a>, are applied to combine singularities.</p><p>Returns a vector of <a href="#CoherentStructures.Singularity"><code>Singularity</code></a>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/4515e41931bb0ba163b20c3fa42753bd17c15141/src/ellipticLCS.jl#L484-L496">source</a></section></article><p>This function takes three steps. The first two are:</p><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.compute_singularities" href="#CoherentStructures.compute_singularities"><code>CoherentStructures.compute_singularities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_singularities(v, dist=s1dist) -&gt; Vector{Singularity}</code></pre><p>Computes critical points and singularities of vector and line fields <code>v</code>, respectively. The argument <code>dist</code> is a signed distance function for angles. Choose <code>s1dist</code> (default) for vector fields, and <code>p1dist</code> for line fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/4515e41931bb0ba163b20c3fa42753bd17c15141/src/ellipticLCS.jl#L206-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.combine_singularities" href="#CoherentStructures.combine_singularities"><code>CoherentStructures.combine_singularities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">combine_singularities(sing_coordinates, sing_indices, combine_distance) -&gt; Vector{Singularity}</code></pre><p>This function does the equivalent of: Build a graph where singularities are vertices, and two vertices share an edge iff the coordinates of the corresponding vertices (given by <code>sing_coordinates</code>) have a distance leq <code>combine_distance</code>. Find all connected components of this graph, and return a list of their mean coordinate and sum of <code>sing_indices</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/4515e41931bb0ba163b20c3fa42753bd17c15141/src/ellipticLCS.jl#L235-L243">source</a></section></article><p>The third step is a postprocessing step, in which detected singularities are merged according to different heuristics.</p><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.combine_20" href="#CoherentStructures.combine_20"><code>CoherentStructures.combine_20</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">combine_20(singularities)</code></pre><p>Determines singularities which are mutually closest neighbors and combines them as one, while adding their indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/4515e41931bb0ba163b20c3fa42753bd17c15141/src/ellipticLCS.jl#L300-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.combine_20_aggressive" href="#CoherentStructures.combine_20_aggressive"><code>CoherentStructures.combine_20_aggressive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">combine_20_aggressive(singularities)</code></pre><p>A heuristic for combining singularities which is likely to have a lot of false positives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/4515e41931bb0ba163b20c3fa42753bd17c15141/src/ellipticLCS.jl#L405-L409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.combine_31" href="#CoherentStructures.combine_31"><code>CoherentStructures.combine_31</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">combine_31(singularities)</code></pre><p>Takes the list of singularities in <code>singularities</code> and combines them so that any -1/2 singularity whose three nearest neighbors are 1/2 singularities becomes an elliptic region, provided that the -1/2 singularity is in the triangle spanned by the wedges. This configuration is common for OECS, applying to material barriers on a large turbulet example yielded only about an additional 1% material barriers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/4515e41931bb0ba163b20c3fa42753bd17c15141/src/ellipticLCS.jl#L349-L358">source</a></section></article><p>The function <a href="#CoherentStructures.compute_singularities"><code>compute_singularities</code></a> requires one of two signed distance functions for angles. These are <a href="#CoherentStructures.s1dist"><code>s1dist</code></a> for vector fields, and <a href="#CoherentStructures.p1dist"><code>p1dist</code></a> for line fields.</p><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.s1dist" href="#CoherentStructures.s1dist"><code>CoherentStructures.s1dist</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">s1dist(α, β)</code></pre><p>Computes the signed length of the angle of the shortest circle segment going from angle <code>β</code> to angle <code>α</code>, as computed on the full circle.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; s1dist(π/2, 0)
1.5707963267948966

julia&gt; s1dist(0, π/2)
-1.5707963267948966</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/4515e41931bb0ba163b20c3fa42753bd17c15141/src/ellipticLCS.jl#L174-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.p1dist" href="#CoherentStructures.p1dist"><code>CoherentStructures.p1dist</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">p1dist(α, β)</code></pre><p>Computes the signed length of the angle of the shortest circle segment going from angle <code>β</code> to angle <code>α [± π]</code>, as computed on the half circle.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; p1dist(π, 0)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/4515e41931bb0ba163b20c3fa42753bd17c15141/src/ellipticLCS.jl#L191-L202">source</a></section></article><p>From all virtual/merged singularities those with a suitable index are selected. Around each elliptic singularity the tensor field is localized and passed on for closed orbit detection.</p><h3 id="Closed-orbit-detection-1"><a class="docs-heading-anchor" href="#Closed-orbit-detection-1">Closed orbit detection</a><a class="docs-heading-anchor-permalink" href="#Closed-orbit-detection-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.compute_returning_orbit" href="#CoherentStructures.compute_returning_orbit"><code>CoherentStructures.compute_returning_orbit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_returning_orbit(vf, seed::SVector{2}, save::Bool=false, maxiters=2000, tolerance=1e-8, max_orbit_length=20.0)</code></pre><p>Computes returning orbits under the velocity field <code>vf</code>, originating from <code>seed</code>. The optional argument <code>save</code> controls whether intermediate locations of the returning orbit should be saved. Returns a tuple of <code>orbit</code> and <code>statuscode</code> (<code>0</code> for success, <code>1</code> for <code>maxiters</code> reached, <code>2</code> for out of bounds error, 3 for other error).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/4515e41931bb0ba163b20c3fa42753bd17c15141/src/ellipticLCS.jl#L531-L539">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.compute_closed_orbits" href="#CoherentStructures.compute_closed_orbits"><code>CoherentStructures.compute_closed_orbits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_closed_orbits(ps, ηfield, cache; rev=true, pmin=0.7, pmax=1.5, rdist=1e-4, tolerance_ode=1e-8, maxiters_ode=2000, maxiters_bisection=20)</code></pre><p>Compute the (outermost) closed orbit for a given Poincaré section <code>ps</code>, a vector field constructor <code>ηfield</code>, and an LCScache <code>cache</code>. Keyword arguments <code>pmin</code> and <code>pmax</code> correspond to the range of shift parameters in which closed orbits are sought; <code>rev</code> determines whether closed orbits are sought from the outside inwards (<code>true</code>) or from the inside outwards (<code>false</code>). <code>rdist</code> sets the required return distance for an orbit to be considered as closed. The parameter <code>maxiters_ode</code> gives the maximum number of steps taken by the ODE solver when computing the closed orbit, the ode solver uses tolerance given by <code>tolerance_ode</code>. The parameter <code>maxiters_bisection</code> gives the maximum number of iterations used by the bisection algorithm to find closed orbits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/4515e41931bb0ba163b20c3fa42753bd17c15141/src/ellipticLCS.jl#L599-L611">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../fem/">« FEM-based methods</a><a class="docs-footer-nextpage" href="../Laplace/">Graph Laplacian-based methods »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 13 December 2019 15:11">Friday 13 December 2019</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
