<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Geodesic vortices · CoherentStructures.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CoherentStructures.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/rot_double_gyre/">Rotating double gyre</a></li><li><a class="tocitem" href="../generated/standard_map/">Standard map</a></li><li><a class="tocitem" href="../generated/bickley/">Bickley jet</a></li><li><a class="tocitem" href="../generated/ocean_flow/">Geostrophic ocean flow</a></li><li><a class="tocitem" href="../generated/trajectories/">Working with trajectories</a></li></ul></li><li><span class="tocitem">Related publications</span><ul><li><a class="tocitem" href="../examples_pub_overview/">Overview</a></li><li><a class="tocitem" href="../generated/diffbarriers/">Material diffusion barriers</a></li><li><a class="tocitem" href="../generated/turbulence/">Diffusion barriers in turbulence</a></li><li><a class="tocitem" href="../generated/lifecycle/">Life cycles of Loop Current rings</a></li></ul></li><li><a class="tocitem" href="../basics/">Basics</a></li><li><span class="tocitem">Methods</span><ul><li><a class="tocitem" href="../fem/">FEM-based methods</a></li><li class="is-active"><a class="tocitem" href>Geodesic vortices</a><ul class="internal"><li><a class="tocitem" href="#Background"><span>Background</span></a></li><li><a class="tocitem" href="#Function-documentation"><span>Function documentation</span></a></li></ul></li><li><a class="tocitem" href="../Laplace/">Graph Laplacian-based methods</a></li></ul></li><li><span class="tocitem">Miscellaneous</span><ul><li><a class="tocitem" href="../videos/">Creating animations</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Methods</a></li><li class="is-active"><a href>Geodesic vortices</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Geodesic vortices</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/master/docs/src/elliptic.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Geodesic-elliptic-material-vortices"><a class="docs-heading-anchor" href="#Geodesic-elliptic-material-vortices">Geodesic elliptic material vortices</a><a id="Geodesic-elliptic-material-vortices-1"></a><a class="docs-heading-anchor-permalink" href="#Geodesic-elliptic-material-vortices" title="Permalink"></a></h1><h2 id="Background"><a class="docs-heading-anchor" href="#Background">Background</a><a id="Background-1"></a><a class="docs-heading-anchor-permalink" href="#Background" title="Permalink"></a></h2><p>The following functions implement an LCS methodology developed in the following papers:</p><ul><li><a href="https://doi.org/10.1016/j.physd.2012.06.012">Haller &amp; Beron-Vera, 2012</a></li><li><a href="https://doi.org/10.1017/jfm.2013.391">Haller &amp; Beron-Vera, 2013</a></li><li><a href="https://doi.org/10.1098/rspa.2014.0639">Karrasch, Huhn, and Haller, 2015</a></li></ul><p>Our implementation here follows conceptually <a href="https://doi.org/10.1098/rspa.2014.0639">Karrasch, Huhn, and Haller, 2015</a>, and is described in detail in the preprint TBD. Depending on the indefinite metric tensor field used, the functions below yield the following types of coherent structures:</p><ul><li>black-hole/Lagrangian coherent vortices (<a href="https://doi.org/10.1017/jfm.2013.391">Haller &amp; Beron-Vera, 2012</a>)</li><li>elliptic objective Eulerian coherent structures (OECSs) (<a href="https://doi.org/10.1063/1.4951720">Serra &amp; Haller, 2016</a>)</li><li>material diffusive transport barriers (<a href="https://doi.org/10.1073/pnas.1720177115">Haller, Karrasch, and Kogelbauer, 2018</a>)</li></ul><p>The general procedure is the following. Assume <span>$T$</span> is the symmetric tensor field of interest, say, (i) the Cauchy-Green strain tensor field <span>$C$</span>, (ii) the rate-of-strain tensor field <span>$S$</span>, or (iii) the averaged diffusion-weighted Cauchy-Green tensor field <span>$\bar{C}_D$</span>; cf. the references above. Denote by <span>$0&lt;\lambda_1\leq\lambda_2$</span> the eigenvalue and by <span>$\xi_1$</span> and <span>$\xi_2$</span> the corresponding eigenvector fields of <span>$T$</span>. Then the direction fields of interest are given by</p><p class="math-container">\[\eta_{\lambda}^{\pm} := \sqrt{\frac{\lambda_2 - \lambda}{\lambda_2-\lambda_1}}\xi_1 \pm \sqrt{\frac{\lambda - \lambda_1}{\lambda_2-\lambda_1}}\xi_2.\]</p><p>Tensor singularities are defined as points at which <span>$\lambda_2=\lambda_1$</span>, i.e., at which the two characteristic directions <span>$\xi_1$</span> and <span>$\xi_2$</span> are not well-defined. As described and exploited in <a href="https://doi.org/10.1098/rspa.2014.0639">Karrasch et al., 2015</a>, non-negligible tensor singularities express themselves by an angle gap when tracking (the angle of) tensor eigenvector fields along closed paths surrounding the singularity. Our approach here avoids computing singularities directly, but rather computes the index for each grid cell and then combines nearby singularities, i.e., adds non-vanishing indices of nearby grid cells.</p><p>In summary, the implementation consists of the following steps:</p><ol><li>compute the index for each grid cell and combine nearby singular grid cells to &quot;singularity candidates&quot;;</li><li>look for elliptic singularity candidates (and potentially isolated wedge pairs);</li><li>place an eastwards oriented Poincaré section at the pair center;</li><li>for each point on the discretized Poincaré section, scan through the given parameter interval such that the corresponding η-orbit closes at that point;</li><li>if desired: for each Poincaré section, take the outermost closed orbit as the coherent vortex barrier (if there exist any).</li></ol><h2 id="Function-documentation"><a class="docs-heading-anchor" href="#Function-documentation">Function documentation</a><a id="Function-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Function-documentation" title="Permalink"></a></h2><h3 id="Meta-functions"><a class="docs-heading-anchor" href="#Meta-functions">Meta-functions</a><a id="Meta-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Meta-functions" title="Permalink"></a></h3><p>The fully automated high-level functions are:</p><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.ellipticLCS" href="#CoherentStructures.ellipticLCS"><code>CoherentStructures.ellipticLCS</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ellipticLCS(T::AbstractMatrix, xspan, yspan, p; kwargs...)</code></pre><p>Computes elliptic LCSs as null-geodesics of the Lorentzian metric tensor field given by shifted versions of <code>T</code> on the 2D computational grid spanned by <code>xspan</code> and <code>yspan</code>. <code>p</code> is a <a href="#CoherentStructures.LCSParameters"><code>LCSParameters</code></a>-type container of computational parameters. Returns a list of <code>EllipticBarrier</code>-type objects.</p><p><strong>Keyword arguments</strong></p><ul><li><code>outermost=true</code>: only the outermost barriers, i.e., the vortex boundaries are returned, otherwise all detected transport barrieres;</li><li><code>verbose=true</code>: show intermediate computational information;</li><li><code>unique_vortices=true</code>: filter out vortices enclosed by other vortices;</li><li><code>suggested_centers=[]</code>: suggest vortex centers (of type <a href="#CoherentStructures.Singularity"><code>Singularity</code></a>);</li><li><code>debug=false</code>: whether to use the debug mode, which avoids parallelization for more precise error messages;</li><li><code>singularity_predicate = nothing</code>: provide an optional callback to reject certain singularity candidates.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L856-L875">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.constrainedLCS" href="#CoherentStructures.constrainedLCS"><code>CoherentStructures.constrainedLCS</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">constrainedLCS(T::AbstractMatrix, xspan, yspan, p; kwargs...)
constrainedLCS(T::AxisArray, p; kwargs...)</code></pre><p>Computes constrained transport barriers as closed orbits of the transport vector field on the 2D computational grid spanned by <code>xspan</code> and <code>yspan</code>. <code>p</code> is an <a href="#CoherentStructures.LCSParameters"><code>LCSParameters</code></a>-type container of computational parameters. Returns a list of <code>EllipticBarrier</code>-type objects.</p><p>The keyword arguments and their default values are:</p><ul><li><code>outermost=true</code>: only the outermost barriers, i.e., the vortex   boundaries are returned, otherwise all detected transport barrieres;</li><li><code>verbose=true</code>: show intermediate computational information</li><li><code>debug=false</code>: whether to use the debug mode, which avoids parallelization   for more precise error messages.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L1223-L1238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.materialbarriers" href="#CoherentStructures.materialbarriers"><code>CoherentStructures.materialbarriers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">materialbarriers(odefun, xspan, yspan, tspan, lcsp;
    on_torus=false, δ=1e-6, tolerance=1e-6, p=nothing, kwargs...)</code></pre><p>Calculate material barriers to diffusive and stochastic transport on the material domain spanned by <code>xspan</code> and <code>yspan</code>, where the averaged weighted CG tensor is computed at the time instance contained in <code>tspan</code>. The argument <code>lcsp</code> must be of type <a href="#CoherentStructures.LCSParameters"><code>LCSParameters</code></a>, and contains parameters used for the elliptic vortex detection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L1521-L1529">source</a></section></article><p>One of their arguments is a list of parameters used in the LCS detection. This list is combined in a data type called <code>LCSParameters</code>. The output is a list of <code>EllipticBarrier</code>s and a list of <code>Singularity</code>s. There is an option to retrieve all closed barriers (<code>outermost=false</code>), in contrast to extracting only the outermost vortex boundaries (<code>outermost=true</code>), which is more efficient.</p><p>The meta-functions consist of two steps: first, the index theory-based determination of where to search for closed orbits,, cf. <a href="#Index-theory-based-placement-of-Poincaré-sections">Index theory-based placement of Poincaré sections</a>; second, the closed orbit computation, cf. <a href="#Closed-orbit-detection">Closed orbit detection</a>.</p><h3 id="Specific-types"><a class="docs-heading-anchor" href="#Specific-types">Specific types</a><a id="Specific-types-1"></a><a class="docs-heading-anchor-permalink" href="#Specific-types" title="Permalink"></a></h3><p>These are the specifically introduced types for elliptic LCS computations.</p><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.LCSParameters" href="#CoherentStructures.LCSParameters"><code>CoherentStructures.LCSParameters</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Container for parameters used in elliptic LCS computations.</p><p><strong>Fields</strong></p><ul><li><code>boxradius</code>: &quot;radius&quot; of localization square for closed orbit detection</li><li><code>indexradius=1e-1boxradius</code>: radius for singularity type detection</li><li><code>merge_heuristics</code>: a list of <a href="#CoherentStructures.MergeHeuristic"><code>MergeHeuristic</code></a>s for combining singularities</li><li><code>n_seeds=100</code>: number of seed points on the Poincaré section</li><li><code>pmin=0.7</code>: lower bound on the parameter in the <span>$\eta$</span>-field</li><li><code>pmax=2.0</code>: upper bound on the parameter in the <span>$\eta$</span>-field</li><li><code>rdist=1e-4boxradius</code>: required return distances for closed orbits</li><li><code>tolerance_ode=1e-8boxradius</code>: absolute and relative tolerance in orbit integration</li><li><code>maxiters_ode::Int=2000</code>: maximum number of integration steps</li><li><code>max_orbit_length=8boxradius</code>: maximum length of orbit length</li><li><code>maxiters_bisection::Int=20</code>: maximum steps in bisection procedure</li><li><code>only_enclosing::Bool=true</code>: whether the orbit must enclose the starting point of the Poincaré section</li><li><code>only_smooth::Bool=true</code>: whether or not to reject orbits with &quot;corners&quot;.</li><li><code>only_uniform::Bool=true</code>: whether or not to reject orbits that are not uniform</li></ul><p><strong>Example</strong></p><pre><code class="language-repl hljs">p = LCSParameters(2.5)
LCSParameters(2.5, 0.25, true, 100, 0.7, 2.0, 0.00025, 2.5e-8, 1000, 20.0, 30)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L105-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.EllipticBarrier" href="#CoherentStructures.EllipticBarrier"><code>CoherentStructures.EllipticBarrier</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This is a container for coherent vortex boundaries. An object <code>barrier</code> of type <code>EllipticBarrier</code> can be easily plotted by <code>plot(barrier.curve)</code>, or <code>plot!([figure, ]barrier.curve)</code> if it is to be overlaid over an existing plot.</p><p><strong>Fields</strong></p><ul><li><code>curve</code>: a vector of tuples, contains the coordinates of coherent vortex boundary points;</li><li><code>core</code>: location of the vortex core;</li><li><code>p</code>: contains the parameter value of the direction field <span>$\eta_{\lambda}^{\pm}$</span>, for which the <code>curve</code> is a closed orbit;</li><li><code>s</code>: a <code>Bool</code> value, which encodes the sign in the formula of the direction field <span>$\eta_{\lambda}^{\pm}$</span> via the formula <span>$(-1)^s$</span>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L61-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.EllipticVortex" href="#CoherentStructures.EllipticVortex"><code>CoherentStructures.EllipticVortex</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This is a container for an elliptic vortex, as represented by the vortex&#39;s <code>center</code> and a list <code>barriers</code> of all computed <a href="#CoherentStructures.EllipticBarrier"><code>EllipticBarrier</code></a>s.</p><p><strong>Fields</strong></p><ul><li><code>center</code>: location of the vortex center;</li><li><code>barriers</code>: vector of <code>EllipticBarrier</code>s.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L83-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.MergeHeuristic" href="#CoherentStructures.MergeHeuristic"><code>CoherentStructures.MergeHeuristic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type MergeHeuristic</code></pre><p>Abstract supertype for merge heuristics, which currently include <a href="#CoherentStructures.Combine"><code>Combine</code></a>, <a href="#CoherentStructures.Combine20"><code>Combine20</code></a>, <a href="#CoherentStructures.Combine20Aggressive"><code>Combine20Aggressive</code></a>, <a href="#CoherentStructures.Combine31"><code>Combine31</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L42-L47">source</a></section></article><p>Another one is <code>Singularity</code>, which comes along with some convenience functions.</p><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.Singularity" href="#CoherentStructures.Singularity"><code>CoherentStructures.Singularity</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Container type for critical points of vector fields or singularities of line fields.</p><p><strong>Fields</strong></p><ul><li><code>coords::SVector{2}</code>: coordinates of the singularity</li><li><code>index::Rational</code>: index of the singularity</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L5-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.getcoords" href="#CoherentStructures.getcoords"><code>CoherentStructures.getcoords</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getcoords(singularities)</code></pre><p>Extracts the coordinates of <code>singularities</code>, a vector of <code>Singularity</code>s. Returns a vector of <code>SVector</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.getindices" href="#CoherentStructures.getindices"><code>CoherentStructures.getindices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getindices(singularities)</code></pre><p>Extracts the indices of <code>singularities</code>, a vector of <code>Singularity</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L34-L38">source</a></section></article><h3 id="Index-theory-based-placement-of-Poincaré-sections"><a class="docs-heading-anchor" href="#Index-theory-based-placement-of-Poincaré-sections">Index theory-based placement of Poincaré sections</a><a id="Index-theory-based-placement-of-Poincaré-sections-1"></a><a class="docs-heading-anchor-permalink" href="#Index-theory-based-placement-of-Poincaré-sections" title="Permalink"></a></h3><p>This is performed by <a href="#CoherentStructures.singularity_detection"><code>singularity_detection</code></a> for line fields (such as eigenvector fields of symmetric positive-definite tensor fields) and by <a href="#CoherentStructures.critical_point_detection"><code>critical_point_detection</code></a> for classic vector fields.</p><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.singularity_detection" href="#CoherentStructures.singularity_detection"><code>CoherentStructures.singularity_detection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">singularity_detection(T, xspan, yspan, combine_distance; merge_heuristics=(Combine20(),)) -&gt; Vector{Singularity}
singularity_detection(T::AxisArray, combine_distance; merge_heuristics=(Combine20(),)) -&gt; Vector{Singularity}</code></pre><p>Calculate line-field singularities of the first eigenvector of <code>T</code> by taking a discrete differential-geometric approach. Singularities are calculated on each cell. Singularities with distance less or equal to <code>combine_distance</code> are combined by averaging the coordinates and adding the respective indices. The heuristics listed in <code>merge_heuristics</code> are used to merge singularities, cf. <a href="#CoherentStructures.LCSParameters"><code>LCSParameters</code></a>.</p><p>Return a vector of <a href="#CoherentStructures.Singularity"><code>Singularity</code></a>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L626-L637">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.critical_point_detection" href="#CoherentStructures.critical_point_detection"><code>CoherentStructures.critical_point_detection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">critical_point_detection(vs, xspan, yspan, combine_distance, dist=S1Dist();
    merge_heuristics=(combine_20,)) -&gt; Vector{Singularity}
critical_point_detection(vs::AxisArray, combine_distance, dist=S1Dist();
    merge_heuristics=(combine_20,)) -&gt; Vector{Singularity}</code></pre><p>Computes critical points of a vector/line field <code>vs</code>, potentially given as an <code>AxisArray</code>. Critical points with distance less or equal to <code>combine_distance</code> are combined by averaging the coordinates and adding the respective indices. The argument <code>dist</code> is a signed distance function for angles: choose <a href="#CoherentStructures.S1Dist"><code>S1Dist()</code></a> for vector fields, and <a href="#CoherentStructures.P1Dist"><code>P1Dist()</code></a> for line fields; cf. <a href="#CoherentStructures.compute_singularities"><code>compute_singularities</code></a>. <a href="#CoherentStructures.MergeHeuristic"><code>MergeHeuristic</code></a>s listed in <code>merge_heuristics</code>, cf. <a href="#CoherentStructures.LCSParameters"><code>LCSParameters</code></a>, are applied to combine singularities.</p><p>Returns a vector of <a href="#CoherentStructures.Singularity"><code>Singularity</code></a>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L584-L599">source</a></section></article><p>This function takes three steps. The first two are:</p><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.compute_singularities" href="#CoherentStructures.compute_singularities"><code>CoherentStructures.compute_singularities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_singularities(v, xspan, yspan, dist=S1Dist()) -&gt; Vector{Singularity}    
compute_singularities(v::AxisArray, dist=S1Dist()) -&gt; Vector{Singularity}</code></pre><p>Computes critical points and singularities of vector and line fields <code>v</code>, respectively. The argument <code>dist</code> is a signed distance function for angles. Choose <code>s1dist</code> (default) for vector fields, and <code>p1dist</code> for line fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L298-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.Combine" href="#CoherentStructures.Combine"><code>CoherentStructures.Combine</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Combine(dist)(sing_coordinates) -&gt; Vector{Singularity}</code></pre><p>This function does the equivalent of: build a graph where singularities are vertices, and two vertices share an edge iff the coordinates of the corresponding vertices (given by <code>sing_coordinates</code>) have a distance leq <code>dist</code>. Find all connected components of this graph, and return a list of their mean coordinate and sum of <code>sing_indices</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L336-L343">source</a></section></article><p>The third step is a postprocessing step, in which detected singularities are merged according to different heuristics.</p><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.Combine20" href="#CoherentStructures.Combine20"><code>CoherentStructures.Combine20</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Combine20()(singularities)</code></pre><p>Determines singularities which are mutually closest neighbors and combines them as one, while adding their indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L401-L406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.Combine31" href="#CoherentStructures.Combine31"><code>CoherentStructures.Combine31</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Combine31()(singularities)</code></pre><p>Takes the list of singularities in <code>singularities</code> and combines them so that any -1/2 singularity whose three nearest neighbors are 1/2 singularities becomes an elliptic region, provided that the -1/2 singularity is in the triangle spanned by the wedges. This configuration is common for OECS, applying to material barriers on a large turbulent example yielded only about an additional 1% material barriers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L450-L459">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.Combine20Aggressive" href="#CoherentStructures.Combine20Aggressive"><code>CoherentStructures.Combine20Aggressive</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Combine20Aggressive()(singularities)</code></pre><p>A heuristic for combining singularities which is likely to have a lot of false positives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L510-L514">source</a></section></article><p>The function <a href="#CoherentStructures.compute_singularities"><code>compute_singularities</code></a> requires one of two signed distance functions for angles. These are <a href="#CoherentStructures.S1Dist"><code>S1Dist</code></a> for vector fields, and <a href="#CoherentStructures.P1Dist"><code>P1Dist</code></a> for line fields.</p><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.S1Dist" href="#CoherentStructures.S1Dist"><code>CoherentStructures.S1Dist</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">S1Dist()(α, β)</code></pre><p>Computes the signed length of the angle of the shortest circle segment going from angle <code>β</code> to angle <code>α</code>, as computed on the full circle.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dist = S1Dist();

julia&gt; dist(π/2, 0)
1.5707963267948966

julia&gt; dist(0, π/2)
-1.5707963267948966</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L257-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.P1Dist" href="#CoherentStructures.P1Dist"><code>CoherentStructures.P1Dist</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">P1Dist()(α, β)</code></pre><p>Computes the signed length of the angle of the shortest circle segment going from angle <code>β</code> to angle <code>α [± π]</code>, as computed on the half circle.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dist = P1Dist();

julia&gt; dist(π, 0)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L279-L293">source</a></section></article><p>From all virtual/merged singularities those with a suitable index are selected. Around each elliptic singularity the tensor field is localized and passed on for closed orbit detection.</p><h3 id="Closed-orbit-detection"><a class="docs-heading-anchor" href="#Closed-orbit-detection">Closed orbit detection</a><a id="Closed-orbit-detection-1"></a><a class="docs-heading-anchor-permalink" href="#Closed-orbit-detection" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.compute_returning_orbit" href="#CoherentStructures.compute_returning_orbit"><code>CoherentStructures.compute_returning_orbit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_returning_orbit(vf, seed::SVector{2}, save::Bool=false, maxiters=2000, tolerance=1e-8, max_orbit_length=20.0)</code></pre><p>Computes returning orbits under the velocity field <code>vf</code>, originating from <code>seed</code>. The optional argument <code>save</code> controls whether intermediate locations of the returning orbit should be saved. Returns a tuple of <code>orbit</code> and <code>statuscode</code> (<code>0</code> for success, <code>1</code> for <code>maxiters</code> reached, <code>2</code> for out of bounds error, 3 for other error).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L662-L670">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.compute_closed_orbits" href="#CoherentStructures.compute_closed_orbits"><code>CoherentStructures.compute_closed_orbits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_closed_orbits(ps, ηfield, cache; kwargs...)</code></pre><p>Compute the (outermost) closed orbit for a given Poincaré section <code>ps</code>, a vector field constructor <code>ηfield</code>, and an LCScache <code>cache</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>rev=true</code>: determines whether closed orbits are sought from the outside inwards (<code>true</code>) or from the inside outwards (<code>false</code>);</li><li><code>p::LCSParameters</code>: an object holding the parameters for the LCS computation; see <a href="#CoherentStructures.LCSParameters"><code>LCSParameters</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L731-L742">source</a></section></article><h3 id="Convenience-functions"><a class="docs-heading-anchor" href="#Convenience-functions">Convenience functions</a><a id="Convenience-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Convenience-functions" title="Permalink"></a></h3><p>First of all, <a href="#CoherentStructures.Singularity"><code>Singularity</code></a>, <a href="#CoherentStructures.EllipticBarrier"><code>EllipticBarrier</code></a> and <a href="#CoherentStructures.EllipticVortex"><code>EllipticVortex</code></a> objects can be passed as initial conditions to the <a href="../basics/#CoherentStructures.flow"><code>flow</code></a> function, which returns a (time-resolved) vector of corresponding objects. Moreover, we have advection with adaptive point insertion (known in oceanography as &quot;Dritschel advection&quot;) and an function to compute the area of <a href="#CoherentStructures.EllipticBarrier"><code>EllipticBarrier</code></a> and <a href="#CoherentStructures.EllipticVortex"><code>EllipticVortex</code></a> objects.</p><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.FlowGrowParams" href="#CoherentStructures.FlowGrowParams"><code>CoherentStructures.FlowGrowParams</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FlowGrowParams</code></pre><p>Container for parameters used in point-inserting flow computations; see <a href="#CoherentStructures.flowgrow"><code>flowgrow</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>maxcurv=0.3</code>: maximal bound on the absolute value of the discrete curvature;</li><li><code>mindist=0.1</code>: least acceptable distance between two consecutive points;</li><li><code>maxdist=1.0</code>: maximal acceptable distance between two consecutive points.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L228-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.flowgrow" href="#CoherentStructures.flowgrow"><code>CoherentStructures.flowgrow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flowgrow(odefun, curve, tspan, params; kwargs...)</code></pre><p>Advect <code>curve</code> with point insertion by the ODE with right hand side <code>odefun</code> over the time interval <code>tspan</code>, evaluated at each element of <code>tspan</code>. This method is known in oceanography as Dritschel&#39;s method. The point insertion method is controlled by the parameters stored in <code>params::FlowGrowParams</code>; cf. <a href="#CoherentStructures.FlowGrowParams"><code>FlowGrowParams</code></a>. Keyword arguments <code>kwargs</code> are passed to the <a href="../basics/#CoherentStructures.flow"><code>flow</code></a> function.</p><p>Convenience methods for <a href="#CoherentStructures.EllipticBarrier"><code>EllipticBarrier</code></a> and [<code>EllipticVortex</code>] objects in place of <code>curve</code> exist. In this case, the method returns a vector of length <code>length(tspan)</code> of corresponding objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L1628-L1640">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.area" href="#CoherentStructures.area"><code>CoherentStructures.area</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">area(polygon)</code></pre><p>Compute the enclosed area of <code>polygon</code>, which can be of type <code>Vector{SVector{2}}</code>, <code>EllipticBarrier</code> or <code>EllipticVortex</code>. In the latter case, the enclosed area of the outermost (i.e., the last <code>EllipticBarrier</code> in the <code>barriers</code> field) is computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L1666-L1672">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.centroid" href="#CoherentStructures.centroid"><code>CoherentStructures.centroid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">centroid(polygon)</code></pre><p>Compute the center (of mass) of <code>polygon</code>, which can be of type <code>Vector{SVector{2}}</code>, <code>EllipticBarrier</code> or <code>EllipticVortex</code>. In the latter case, the center of the outermost (i.e., the last <code>EllipticBarrier</code> in the <code>barriers</code> field) is computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L1688-L1694">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoherentStructures.clockwise" href="#CoherentStructures.clockwise"><code>CoherentStructures.clockwise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">clockwise(barrier, velocity, t0; p=nothing) -&gt; Bool
clockwise(vortex, velocity, t0; p=nothing) -&gt; Bool</code></pre><p>Determine whether a given <code>vortex</code> or <code>barrier</code> is instantaneously (at <code>t0</code>) rotating clockwise due to the velocity field <code>velocity</code>. The keyword argument <code>p</code> is a parameter passed to <code>velocity</code>, for instance the interpolant of the interpolating velocity field <a href="../basics/#CoherentStructures.interp_rhs"><code>interp_rhs</code></a>.</p><p>Clockwise-rotating vortices correspond to anticyclones in the Northern hemisphere and to cyclones in the Southern hemisphere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L1729-L1740">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.extrema-Tuple{CoherentStructures.EllipticBarrier}" href="#Base.extrema-Tuple{CoherentStructures.EllipticBarrier}"><code>Base.extrema</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.extrema(barrier) -&gt; (LL, UR)
Base.extrema(vortex) -&gt; (LL, UR)</code></pre><p>Compute an axis-aligned, rectangular bounding box around an <a href="#CoherentStructures.EllipticVortex"><code>EllipticVortex</code></a> or an <a href="#CoherentStructures.EllipticBarrier"><code>EllipticBarrier</code></a>. Returns the coordinates of the lower left corner <code>LL</code> and of the upper right corner <code>UR</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/f153c95db953985ba4af5c87c2fb7e6ba2288e81/src/ellipticLCS.jl#L1714-L1721">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../fem/">« FEM-based methods</a><a class="docs-footer-nextpage" href="../Laplace/">Graph Laplacian-based methods »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.6 on <span class="colophon-date" title="Wednesday 29 September 2021 16:50">Wednesday 29 September 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
