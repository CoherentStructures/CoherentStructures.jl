<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Geodesic vortices · CoherentStructures.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CoherentStructures.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../generated/rot_double_gyre/">Rotating double gyre</a></li><li><a class="toctext" href="../generated/standard_map/">Standard map</a></li><li><a class="toctext" href="../generated/bickley/">Bickley jet</a></li><li><a class="toctext" href="../generated/ocean_flow/">Geostrophic ocean flow</a></li></ul></li><li><a class="toctext" href="../basics/">Basics</a></li><li><span class="toctext">Methods</span><ul><li><a class="toctext" href="../fem/">FEM-based methods</a></li><li class="current"><a class="toctext" href>Geodesic vortices</a><ul class="internal"><li><a class="toctext" href="#Function-documentation-1">Function documentation</a></li></ul></li><li><a class="toctext" href="../Laplace/">Graph Laplacian-based methods</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Methods</li><li><a href>Geodesic vortices</a></li></ul><a class="edit-page" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/master/docs/src/elliptic.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Geodesic vortices</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Geodesic-elliptic-material-vortices-1" href="#Geodesic-elliptic-material-vortices-1">Geodesic elliptic material vortices</a></h1><p>The following functions implement an LCS methodology developed in the following papers:</p><ul><li><a href="https://dx.doi.org/10.1016/j.physd.2012.06.012">Haller &amp; Beron-Vera, 2012</a></li><li><a href="https://dx.doi.org/10.1017/jfm.2013.391">Haller &amp; Beron-Vera, 2013</a></li><li><a href="https://dx.doi.org/10.1098/rspa.2014.0639">Karrasch, Huhn, and Haller, 2015</a></li></ul><p>The present code was originally inspired by Alireza Hadjighasem&#39;s <a href="https://github.com/Hadjighasem/Elliptic_LCS_2D">MATLAB implementation</a>, which was written in the context of the <a href="https://doi.org/10.1137/140983665">SIAM Review paper</a>, but has been significantly modified and improved throughout. Depending on the indefinite metric tensor field used, the functions below yield the following types of coherent structures:</p><ul><li>black-hole/Lagrangian coherent vortices (<a href="https://doi.org/10.1017/jfm.2013.391">Haller &amp; Beron-Vera, 2012</a>)</li><li>elliptic objective Eulerian coherent structures (OECSs) (<a href="https://dx.doi.org/10.1063/1.4951720">Serra &amp; Haller, 2016</a>)</li><li>material diffusive transport barriers (<a href="https://doi.org/10.1073/pnas.1720177115">Haller, Karrasch, and Kogelbauer, 2018</a>)</li></ul><p>The general procedure is the following. Assume <span>$T$</span> is the symmetric tensor field of interest, say, (i) the Cauchy-Green strain tensor field <span>$C$</span>, (ii) the rate-of-strain tensor field <span>$S$</span>, or (iii) the averaged diffusion-weighted Cauchy-Green tensor field <span>$\bar{C}_D$</span>; cf. the references above. Denote by <span>$0&lt;\lambda_1\leq\lambda_2$</span> the eigenvalue and by <span>$\xi_1$</span> and <span>$\xi_2$</span> the corresponding eigenvector fields of <span>$T$</span>. Then the direction fields of interest are given by</p><div>\[\eta_{\lambda}^{\pm} := \sqrt{\frac{\lambda_2 - \lambda}{\lambda_2-\lambda_1}}\xi_1 \pm \sqrt{\frac{\lambda - \lambda_1}{\lambda_2-\lambda_1}}\xi_2.\]</div><p>Tensor singularities are defined as points at which <span>$\lambda_2=\lambda_1$</span>, i.e., at which the two characteristic directions <span>$\xi_1$</span> and <span>$\xi_2$</span> are not well-defined. As described and exploited in <a href="https://dx.doi.org/10.1098/rspa.2014.0639">Karrasch et al., 2015</a>, non-negligible tensor singularities express themselves by an angle gap when tracking (the angle of) tensor eigenvector fields along closed paths surrounding the singularity. Our approach here avoids computing singularities directly, but rather computes the index for each grid cell and then combines nearby singularities, i.e., adds non-vanishing indices of nearby grid cells.</p><p>In summary, the implementation consists of the following steps:</p><ol><li>compute the index for each grid cell and combine nearby singular grid cells to &quot;singularity candidates&quot;;</li><li>look for elliptic singularity candidates (and potentially isolated wedge pairs);</li><li>place an eastwards oriented Poincaré section at the pair center;</li><li>for each point on the discretized Poincaré section, scan through the given parameter interval such that the corresponding η-orbit closes at that point;</li><li>if desired: for each Poincaré section, take the outermost closed orbit as the coherent vortex barrier (if there exist any).</li></ol><h2><a class="nav-anchor" id="Function-documentation-1" href="#Function-documentation-1">Function documentation</a></h2><h3><a class="nav-anchor" id="The-meta-functions-ellipticLCS-and-constrainedLCS-1" href="#The-meta-functions-ellipticLCS-and-constrainedLCS-1">The meta-functions <code>ellipticLCS</code> and <code>constrainedLCS</code></a></h3><p>The fully automated high-level functions are:</p><pre><code class="language-none">ellipticLCS
constrainedLCS</code></pre><p>One of their arguments is a list of parameters used in the LCS detection. This list is combined in a data type called <code>LCSParameters</code>. The output is a list of <code>EllipticBarrier</code>s and a list of <code>Singularity</code>s. There is an option to retrieve all closed barriers (<code>outermost=false</code>), in contrast to extracting only the outermost vortex boundaries (<code>outermost=true</code>), which is more efficient.</p><p>The meta-functions consist of two steps: first, the index theory-based determination of where to search for closed orbits,, cf. <a href="#Index-theory-based-placement-of-Poincaré-sections-1">Index theory-based placement of Poincaré sections</a>; second, the closed orbit computation, cf. <a href="#Closed-orbit-detection-1">Closed orbit detection</a>.</p><h3><a class="nav-anchor" id="Specific-types-1" href="#Specific-types-1">Specific types</a></h3><p>These are the specifically introduced types for elliptic LCS computations.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.LCSParameters" href="#CoherentStructures.LCSParameters"><code>CoherentStructures.LCSParameters</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct LCSParameters</code></pre><p>Container for parameters used in elliptic LCS computations.</p><p><strong>Fields</strong></p><ul><li><code>indexradius::Float64=0.1</code>: radius for singularity type detection</li><li><code>boxradius::Float64=0.5</code>: &quot;radius&quot; of localization square for closed orbit detection</li><li><code>combine_pairs=true</code>: whether isolated singularity pairs should be merged</li><li><code>n_seeds::Int64=40</code>: number of seed points on the Poincaré section</li><li><code>pmin::Float64=0.7</code>: lower bound on the parameter in the <span>$\eta$</span>-field</li><li><code>pmax::Float64=1.3</code>: upper bound on the parameter in the <span>$\eta$</span>-field</li><li><code>rdist::Float64=1e-4</code>: required return distances for closed orbits</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/34ee1da53d34c78444e2eff5275a1d976c2265a6/src/ellipticLCS.jl#L45-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.EllipticBarrier" href="#CoherentStructures.EllipticBarrier"><code>CoherentStructures.EllipticBarrier</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct EllipticBarrier</code></pre><p>This is a container for coherent vortex boundaries. An object <code>vortex</code> of type <code>EllipticBarrier</code> can be easily plotted by <code>plot(vortex.curve)</code>, or <code>plot!([figure, ]vortex.curve)</code> if it is to be overlaid over an existing plot.</p><p><strong>Fields</strong></p><ul><li><code>curve</code>: a list of tuples, contains the coordinates of coherent vortex boundary points;</li><li><code>core</code>: location of the vortex core;</li><li><code>p</code>: contains the parameter value of the direction field <span>$\eta_{\lambda}^{\pm}$</span>, for the <code>curve</code> is a closed orbit;</li><li><code>s</code>: a <code>Bool</code> value, which encodes the sign in the formula of the direction field <span>$\eta_{\lambda}^{\pm}$</span> via the formula <span>$(-1)^s$</span>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/34ee1da53d34c78444e2eff5275a1d976c2265a6/src/ellipticLCS.jl#L22-L37">source</a></section><p>Another one is <code>Singularity</code>, which comes along with some convenience functions.</p><pre><code class="language-none">Singularity
getcoords
getindices</code></pre><h3><a class="nav-anchor" id="Index-theory-based-placement-of-Poincaré-sections-1" href="#Index-theory-based-placement-of-Poincaré-sections-1">Index theory-based placement of Poincaré sections</a></h3><p>This is performed by <a href="@ref"><code>discrete_singularity_detection</code></a> for line fields (such as eigenvector fields of symmetric positive-definit tensor fields) and by <a href="#CoherentStructures.critical_point_detection"><code>critical_point_detection</code></a> for classic vector fields.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.singularity_detection" href="#CoherentStructures.singularity_detection"><code>CoherentStructures.singularity_detection</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">singularity_detection(T, combine_distance; combine_isolated_wedges=true) -&gt; Vector{Singularity}</code></pre><p>Calculates line-field singularities of the first eigenvector of <code>T</code> by taking a discrete differential-geometric approach. Singularities are calculated on each cell. Singularities with distance less or equal to <code>combine_distance</code> are combined by averaging the coordinates and adding the respective indices. If <code>combine_pairs</code> is `true, pairs of singularities that are mutually the closest ones are included in the final list.</p><p>Returns a vector of <a href="#CoherentStructures.Singularity"><code>Singularity</code></a>s. Returned indices correspond to doubled indices to get integer values.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/34ee1da53d34c78444e2eff5275a1d976c2265a6/src/ellipticLCS.jl#L258-L270">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.critical_point_detection" href="#CoherentStructures.critical_point_detection"><code>CoherentStructures.critical_point_detection</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">critical_point_detection(vs, combine_distance, γ; combine_pairs=true)</code></pre><p>Computes critical points of a vector/line field <code>vs</code>, given as an <code>AxisArray</code>. Critical points with distance less or equal to <code>combine_distance</code> are combined by averaging the coordinates and adding the respective indices. The parameter <code>γ</code> should be chosen <code>π</code> for line fields and <code>2π</code> for vector fields; cf. <a href="#CoherentStructures.compute_singularities"><code>compute_singularities</code></a>. If <code>combine_pairs is</code>true, pairs of singularities that are mutually the closest ones are included in the final list.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/34ee1da53d34c78444e2eff5275a1d976c2265a6/src/ellipticLCS.jl#L232-L241">source</a></section><p>This function takes three steps.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.compute_singularities" href="#CoherentStructures.compute_singularities"><code>CoherentStructures.compute_singularities</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">compute_singularities(α, modulus) -&gt; Vector{Singularity}</code></pre><p>Computes critical points/singularities of vector and line fields, respectively. <code>α</code> is a scalar field (array) which is assumed to contain some consistent angle representation of the vector/line field. Choose <code>modulus=2π</code> for vector fields, and <code>modulus=π</code> for line fields.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/34ee1da53d34c78444e2eff5275a1d976c2265a6/src/ellipticLCS.jl#L92-L99">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.combine_singularities" href="#CoherentStructures.combine_singularities"><code>CoherentStructures.combine_singularities</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">combine_singularities(sing_coordinates, sing_indices, combine_distance) -&gt; Vector{Singularity}</code></pre><p>This function does the equivalent of: Build a graph where singularities are vertices, and two vertices share an edge iff the coordinates of the corresponding vertices (given by <code>sing_coordinates</code>) have a distance leq <code>combine_distance</code>. Find all connected components of this graph, and return a list of their mean coordinate and sum of <code>sing_indices</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/34ee1da53d34c78444e2eff5275a1d976c2265a6/src/ellipticLCS.jl#L120-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.combine_isolated_pairs" href="#CoherentStructures.combine_isolated_pairs"><code>CoherentStructures.combine_isolated_pairs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">combine_isolated_pairs(singularities)</code></pre><p>Determines singularities which are mutually closest neighbors and combines them as one, while adding their indices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/34ee1da53d34c78444e2eff5275a1d976c2265a6/src/ellipticLCS.jl#L184-L188">source</a></section><p>From all virtual/merged singularities those with a suitable index are selected. Around each elliptic singularity the tensor field is localized and passed on for closed orbit detection.</p><h3><a class="nav-anchor" id="Closed-orbit-detection-1" href="#Closed-orbit-detection-1">Closed orbit detection</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.compute_returning_orbit" href="#CoherentStructures.compute_returning_orbit"><code>CoherentStructures.compute_returning_orbit</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">compute_returning_orbit(vf, seed::SVector{2}, save::Bool=false)</code></pre><p>Computes returning orbits under the velocity field <code>vf</code>, originating from <code>seed</code>. The optional argument <code>save</code> controls whether intermediate locations of the returning orbit should be saved.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/34ee1da53d34c78444e2eff5275a1d976c2265a6/src/ellipticLCS.jl#L279-L284">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.compute_closed_orbits" href="#CoherentStructures.compute_closed_orbits"><code>CoherentStructures.compute_closed_orbits</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">compute_closed_orbits(ps, ηfield, cache; rev=true, pmin=0.7, pmax=1.5, rdist=1e-4)</code></pre><p>Compute the outermost closed orbit for a given Poincaré section <code>ps</code>, a vector field constructor <code>ηfield</code>, and an LCScache <code>cache. Keyword arguments</code>pmin<code>and</code>pmax<code>correspond to the range of shift parameters in which closed orbits are sought;</code>rev<code>determines whether closed orbits are sought from the outside inwards (</code>true<code>) or from the inside outwards (</code>false<code>).</code>rdist` sets the required return distance for an orbit to be considered as closed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/34ee1da53d34c78444e2eff5275a1d976c2265a6/src/ellipticLCS.jl#L345-L354">source</a></section><footer><hr/><a class="previous" href="../fem/"><span class="direction">Previous</span><span class="title">FEM-based methods</span></a><a class="next" href="../Laplace/"><span class="direction">Next</span><span class="title">Graph Laplacian-based methods</span></a></footer></article></body></html>
