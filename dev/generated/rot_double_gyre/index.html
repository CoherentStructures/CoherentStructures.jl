<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Rotating double gyre · CoherentStructures.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CoherentStructures.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Examples</span><ul><li class="current"><a class="toctext" href>Rotating double gyre</a><ul class="internal"><li><a class="toctext" href="#Description-1">Description</a></li><li><a class="toctext" href="#FEM-Based-Methods-1">FEM-Based Methods</a></li><li><a class="toctext" href="#Geodesic-vortices-1">Geodesic vortices</a></li></ul></li><li><a class="toctext" href="../standard_map/">Standard map</a></li><li><a class="toctext" href="../bickley/">Bickley jet</a></li><li><a class="toctext" href="../ocean_flow/">Geostrophic ocean flow</a></li></ul></li><li><a class="toctext" href="../../basics/">Basics</a></li><li><span class="toctext">Methods</span><ul><li><a class="toctext" href="../../fem/">FEM-based methods</a></li><li><a class="toctext" href="../../elliptic/">Geodesic vortices</a></li><li><a class="toctext" href="../../Laplace/">Graph Laplacian-based methods</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Examples</li><li><a href>Rotating double gyre</a></li></ul><a class="edit-page" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/master/examples/rot_double_gyre.jl"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Rotating double gyre</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Rotating-Double-Gyre-1" href="#Rotating-Double-Gyre-1">Rotating Double Gyre</a></h1><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><p>This example is also available as a Jupyter notebook: <a href="https://nbviewer.jupyter.org/github/CoherentStructures/CoherentStructures.jl/blob/gh-pages/dev/generated/rot_double_gyre.ipynb"><code>rot_double_gyre.ipynb</code></a>, and as an executable julia file <a href="https://raw.githubusercontent.com/CoherentStructures/CoherentStructures.jl/gh-pages/dev/generated/rot_double_gyre.jl"><code>rot_double_gyre.jl</code></a>.</p></div></div><h2><a class="nav-anchor" id="Description-1" href="#Description-1">Description</a></h2><p>The rotating double gyre model was introduced by <a href="https://dx.doi.org/10.1137/100794110">Mosovsky &amp; Meiss</a>. It can be derived from the stream function</p><div>\[\psi(x,y,t)=(1−s(t))\psi_P +s(t)\psi_F \\ \psi_P (x, y) = \sin(2\pi x) \sin(\pi y) \\ \psi_F (x, y) = \sin(\pi x) \sin(2\pi y)\]</div><p>where <span>$s$</span> is (usually taken to be) a cubic interpolating function satisfying <span>$s(0) = 0$</span> and <span>$s(1) = 1$</span>. It therefore interpolates two double-gyre-type velocity fields, from horizontally to vertically arranged counter-rotating gyres. The corresponding velocity field is provided by the package and callable as <code>rot_double_gyre</code>.</p><p><img src="https://raw.githubusercontent.com/natschil/misc/db22aeef/images/double_gyre.gif" alt/></p><h2><a class="nav-anchor" id="FEM-Based-Methods-1" href="#FEM-Based-Methods-1">FEM-Based Methods</a></h2><p>The following code demonstrates how to use these methods.</p><pre><code class="language-julia">using CoherentStructures, Arpack
LL = [0.0, 0.0]; UR = [1.0, 1.0];
ctx, _ = regularTriangularGrid((50, 50), LL, UR)

A = x -&gt; mean_diff_tensor(rot_double_gyre, x, [0.0, 1.0], 1.e-10, tolerance= 1.e-4)
K = assembleStiffnessMatrix(ctx, A)
M = assembleMassMatrix(ctx)
λ, v = eigs(-K, M, which=:SM);</code></pre><p>This velocity field is given by the <code>rot_double_gyre</code> function. The third argument to <code>mean_diff_tensor</code> is a vector of time instances at which we evaluate (and subsequently average) the pullback diffusion tensors. The fourth parameter is the step size δ used for the finite-difference scheme, <code>tolerance</code> is passed to the ODE solver from <a href="http://juliadiffeq.org/">DifferentialEquations.jl</a>. In the above, <code>A(x)</code> approximates the mean diffusion tensor given by</p><div>\[A(x) = \sum_{t \in \mathcal T}(D\Phi^t(x))^{-1} (D\Phi^t x)^{-T}\]</div><p>The eigenfunctions saved in <code>v</code> approximate those of <span>$\Delta^{dyn}$</span></p><pre><code class="language-julia">import Plots
res = [plot_u(ctx, v[:,i], 100, 100, colorbar=:none, clim=(-3,3)) for i in 1:6];
fig = Plots.plot(res..., margin=-10Plots.px)</code></pre><p><img src="https://raw.githubusercontent.com/natschil/misc/master/autogen/ rot_double_gyre_fem_eigfuncs.png" alt/></p><p>Looking at the spectrum, there appears a gap after the third eigenvalue.</p><pre><code class="language-julia">spectrum_fig = Plots.scatter(1:6, real.(λ))</code></pre><p><img src="https://raw.githubusercontent.com/natschil/misc/master/autogen/ rot_double_gyre_fem_spectrum.png" alt/></p><p>We can use the <a href="https://github.com/JuliaStats/Clustering.jl">Clustering.jl</a> package to compute coherent structures from the first two nontrivial eigenfunctions:</p><pre><code class="language-julia">using Clustering

ctx2, _ = regularTriangularGrid((200, 200))
v_upsampled = sample_to(v, ctx, ctx2)

numclusters=2
res = kmeans(permutedims(v_upsampled[:,2:numclusters+1]), numclusters + 1)
u = kmeansresult2LCS(res)
res = Plots.plot([plot_u(ctx2, u[:,i], 200, 200, color=:viridis, colorbar=:none) for i in [1,2,3]]...)</code></pre><p><img src="https://raw.githubusercontent.com/natschil/misc/master/autogen/ rot_double_gyre_fem.png" alt/></p><h2><a class="nav-anchor" id="Geodesic-vortices-1" href="#Geodesic-vortices-1">Geodesic vortices</a></h2><p>Here, we demonstrate how to calculate black-hole vortices, see <a href="../../elliptic/#Geodesic-elliptic-material-vortices-1">Geodesic elliptic material vortices</a> for references and details.</p><pre><code class="language-julia">using Distributed
nprocs() == 1 &amp;&amp; addprocs()

@everywhere using CoherentStructures, OrdinaryDiffEq
using StaticArrays
import AxisArrays
const AA = AxisArrays
const q = 51
const tspan = range(0., stop=1., length=q)
nx = ny = 51
xmin, xmax, ymin, ymax = 0.0, 1.0, 0.0, 1.0
xspan = range(xmin, stop=xmax, length=nx)
yspan = range(ymin, stop=ymax, length=ny)
P = AA.AxisArray(SVector{2}.(xspan, yspan&#39;), xspan, yspan)
const δ = 1.e-6
mCG_tensor = u -&gt; av_weighted_CG_tensor(rot_double_gyre, u, tspan, δ;
        tolerance=1e-6, solver=Tsit5())

C̅ = pmap(mCG_tensor, P; batch_size=ny)
p = LCSParameters(0.5)
vortices, singularities = ellipticLCS(C̅, p; outermost=true)</code></pre><p>The results are then visualized as follows.</p><pre><code class="language-julia">using Plots
λ₁, λ₂, ξ₁, ξ₂, traceT, detT = tensor_invariants(C̅)
fig = Plots.heatmap(xspan, yspan, permutedims(log10.(traceT));
            aspect_ratio=1, color=:viridis, leg=true,
            title=&quot;DBS field and transport barriers&quot;,
            xlims=(xmin, xmax), ylims=(ymin, ymax))
scatter!(getcoords(singularities), color=:red, label=&quot;singularities&quot;)
scatter!([vortex.center for vortex in vortices], color=:yellow, label=&quot;vortex cores&quot;)
for vortex in vortices, barrier in vortex.barriers
    plot!(barrier.curve, w=2, label=&quot;T = $(round(barrier.p, digits=2))&quot;)
end</code></pre><p><img src="https://raw.githubusercontent.com/natschil/misc/master/autogen/ rot_double_gyre_geodesic_vortices.png" alt/></p><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><footer><hr/><a class="previous" href="../../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../standard_map/"><span class="direction">Next</span><span class="title">Standard map</span></a></footer></article></body></html>
