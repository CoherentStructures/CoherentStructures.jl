var documenterSearchIndex = {"docs":
[{"location":"videos/#Helper-script-for-creating-high-definition-videos-1","page":"Helper script for creating videos","title":"Helper script for creating high-definition videos","text":"","category":"section"},{"location":"videos/#","page":"Helper script for creating videos","title":"Helper script for creating videos","text":"The following script can be used to create high-definition videos. It is not part of the CoherentStructures.jl package because we did not want to introduce additional dependencies.","category":"page"},{"location":"videos/#","page":"Helper script for creating videos","title":"Helper script for creating videos","text":"WARNING: this script will delete/overwrite the file at output_file.","category":"page"},{"location":"videos/#","page":"Helper script for creating videos","title":"Helper script for creating videos","text":"Example usage, after the script has been loaded:","category":"page"},{"location":"videos/#","page":"Helper script for creating videos","title":"Helper script for creating videos","text":"xs = range(0,stop=10,length=20)\nts = range(0,stop=1.0,length=100)\nframes = [\n    Plots.plot(xs, x -> sin(t*x),ylim=(-1.0,1.0)) for t in ts\n    ]\nanimatemp4(frames) # Saves to /tmp/output.mp4 by default","category":"page"},{"location":"videos/#","page":"Helper script for creating videos","title":"Helper script for creating videos","text":"<video controls=\"\" height=\"100%\" width=\"100%\">\n  <source src=\"https://raw.githubusercontent.com/natschil/misc/master/videos/sample_video.mp4\" type=\"video/mp4\" />\n Your browser does not support the video tag.\n </video>","category":"page"},{"location":"videos/#","page":"Helper script for creating videos","title":"Helper script for creating videos","text":"The script:","category":"page"},{"location":"videos/#","page":"Helper script for creating videos","title":"Helper script for creating videos","text":"using Printf,UUIDs\n\nusing ProgressMeter,Plots\n\nfunction animatemp4(fitr,output_file=\"/tmp/output.mp4\",delete_frames_after=true;density=400,framerate=60)\n    dirn = @sprintf(\"/tmp/animate%s/\",string(UUIDs.uuid1()))\n    mkdir(dirn)\n    try\n        run(`rm $output_file`)\n    catch e\n    end\n    @showprogress \"Saving frames\" for (index,i) in enumerate(fitr)\n        fname = @sprintf(\"%s/still%03d.pdf\",dirn,index)\n        Plots.pdf(i,fname)\n        fnamepng = fname[1:(end-3)] * \"png\"\n        run(`convert -density $density $fname $fnamepng`)\n    end\n    run(`ffmpeg -r 5 -pattern_type glob -i \"$dirn/still*.png\" -framerate $framerate -pix_fmt yuv420p -c:v libx264 -movflags +faststart -filter:v crop='floor(in_w/2)*2:floor(in_h/2)*2' $output_file`)\n    if delete_frames_after\n        run(`rm -rf $dirn`)\n    else\n        println(\"Individual frames saved at $dirn\")\n    end\nend","category":"page"},{"location":"Laplace/#Graph-Laplacian/diffusion-maps-based-LCS-methods-1","page":"Graph Laplacian-based methods","title":"Graph Laplacian/diffusion maps-based LCS methods","text":"","category":"section"},{"location":"Laplace/#","page":"Graph Laplacian-based methods","title":"Graph Laplacian-based methods","text":"CurrentModule = CoherentStructures","category":"page"},{"location":"Laplace/#","page":"Graph Laplacian-based methods","title":"Graph Laplacian-based methods","text":"The LCS approaches implemented and described in this section are strongly influenced by ideas developed in the spectral clustering/diffusion maps communities. The general references include:","category":"page"},{"location":"Laplace/#","page":"Graph Laplacian-based methods","title":"Graph Laplacian-based methods","text":"Shi & Malik, Normalized cuts and image segmentation, 2000\nCoifman & Lafon, Diffusion maps, 2006\nMarshall & Hirn, Time coupled diffusion maps, 2018","category":"page"},{"location":"Laplace/#","page":"Graph Laplacian-based methods","title":"Graph Laplacian-based methods","text":"In the LCS context, these ideas have been adopted in the following works:","category":"page"},{"location":"Laplace/#","page":"Graph Laplacian-based methods","title":"Graph Laplacian-based methods","text":"somewhat related Froyland & Padberg-Gehle, 2015\nHadjighasem et al., 2016\nBanisch & Koltai, 2017\nRypina et al., 2017/Padberg-Gehle & Schneide, 2018","category":"page"},{"location":"Laplace/#","page":"Graph Laplacian-based methods","title":"Graph Laplacian-based methods","text":"For demonstrations on example cases, please consult the page on Working with trajectories.","category":"page"},{"location":"Laplace/#Function-documentation-1","page":"Graph Laplacian-based methods","title":"Function documentation","text":"","category":"section"},{"location":"Laplace/#sparsification_methods-1","page":"Graph Laplacian-based methods","title":"Sparsification methods","text":"","category":"section"},{"location":"Laplace/#","page":"Graph Laplacian-based methods","title":"Graph Laplacian-based methods","text":"Three commonly used sparsification methods are implemented for use with various graph Laplacian methods.","category":"page"},{"location":"Laplace/#","page":"Graph Laplacian-based methods","title":"Graph Laplacian-based methods","text":"KNN\nMutualKNN\nNeighborhood","category":"page"},{"location":"Laplace/#CoherentStructures.KNN","page":"Graph Laplacian-based methods","title":"CoherentStructures.KNN","text":"KNN(k) <: SparsificationMethod\n\nDefines the KNN (k-nearest neighbors) sparsification method. In this approach, first k nearest neighbors are sought. In the final graph Laplacian, only those particle pairs are included which are contained in some k-Neighborhood.\n\n\n\n\n\n","category":"type"},{"location":"Laplace/#CoherentStructures.MutualKNN","page":"Graph Laplacian-based methods","title":"CoherentStructures.MutualKNN","text":"MutualKNN(k) <: SparsificationMethod\n\nDefines the mutual KNN (k-nearest neighbors) sparsification method. In this approach, first k nearest neighbors are sought. In the final graph Laplacian, only those particle pairs are included which are mutually contained in each others k-Neighborhood.\n\n\n\n\n\n","category":"type"},{"location":"Laplace/#CoherentStructures.Neighborhood","page":"Graph Laplacian-based methods","title":"CoherentStructures.Neighborhood","text":"Neighborhood(ε) <: SparsificationMethod\n\nDefines the ε-Neighborhood sparsification method. In the final graph Laplacian, only those particle pairs are included which have distance less than ε.\n\n\n\n\n\n","category":"type"},{"location":"Laplace/#","page":"Graph Laplacian-based methods","title":"Graph Laplacian-based methods","text":"Other sparsification methods can be implemented by defining a SparsificationMethod type and a corresponding spdist method.","category":"page"},{"location":"Laplace/#Diffusion-maps-type/adjancency-matrix-based-graph-Laplacian-methods-1","page":"Graph Laplacian-based methods","title":"Diffusion-maps-type/adjancency-matrix-based graph Laplacian methods","text":"","category":"section"},{"location":"Laplace/#","page":"Graph Laplacian-based methods","title":"Graph Laplacian-based methods","text":"Since the Euclidean heat kernel is ubiquitous in diffusion maps-based computations, we provide it for convenience.","category":"page"},{"location":"Laplace/#","page":"Graph Laplacian-based methods","title":"Graph Laplacian-based methods","text":"gaussian\ngaussiancutoff","category":"page"},{"location":"Laplace/#CoherentStructures.gaussian","page":"Graph Laplacian-based methods","title":"CoherentStructures.gaussian","text":"gaussian(σ=1.0)\n\nReturns the Euclidean heat kernel as a callable function\n\nx mapsto expleft(-fracx^24sigmaright)\n\nExample\n\njulia> kernel = gaussian(2.0);\n\njulia> kernel(0.)\n1.0\n\n\n\n\n\n","category":"function"},{"location":"Laplace/#CoherentStructures.gaussiancutoff","page":"Graph Laplacian-based methods","title":"CoherentStructures.gaussiancutoff","text":"gaussiancutoff(σ, θ)\n\nComputes the positive value at which gaussian(σ) equals θ, i.e.,\n\nsqrt-4sigmalog(theta)\n\n\n\n\n\n","category":"function"},{"location":"Laplace/#","page":"Graph Laplacian-based methods","title":"Graph Laplacian-based methods","text":"To compute a sparse distance matrix (or adjacency matrix, depending on the sparsification method), use spdist.","category":"page"},{"location":"Laplace/#","page":"Graph Laplacian-based methods","title":"Graph Laplacian-based methods","text":"spdist","category":"page"},{"location":"Laplace/#CoherentStructures.spdist","page":"Graph Laplacian-based methods","title":"CoherentStructures.spdist","text":"spdist(data, sp_method, metric=Euclidean()) -> SparseMatrixCSC\n\nReturn a sparse distance matrix as determined by the sparsification method sp_method and metric.\n\n\n\n\n\n","category":"function"},{"location":"Laplace/#","page":"Graph Laplacian-based methods","title":"Graph Laplacian-based methods","text":"The main high-level functions for the above-listed methods are the following.","category":"page"},{"location":"Laplace/#","page":"Graph Laplacian-based methods","title":"Graph Laplacian-based methods","text":"sparse_diff_op_family\nsparse_diff_op","category":"page"},{"location":"Laplace/#CoherentStructures.sparse_diff_op_family","page":"Graph Laplacian-based methods","title":"CoherentStructures.sparse_diff_op_family","text":"sparse_diff_op_family(data, sp_method, kernel, op_reduce; α, metric, verbose)\n\nReturn a list of sparse diffusion/Markov matrices P.\n\nArguments\n\ndata: a list of trajectories, each a list of states of type SVector;\nsp_method: a sparsification method;\nkernel=gaussian(): diffusion kernel, e.g., gaussian;\nop_reduce=P -> prod(LinearMaps.LinearMap, reverse(P)): time-reduction of diffusion operators, e.g. Statistics.mean (space-time diffusion maps), P -> row_normalize!(min.(sum(P), 1)) (network-based coherence) or the default P -> prod(LinearMaps.LinearMap, reverse(P)) (time coupled diffusion maps)\n\nKeyword arguments\n\nα=1: exponent in diffusion-map normalization;\nmetric=Euclidean(): distance function w.r.t. which the kernel is computed, however, only for point pairs where metric(x_i x_j)leq varepsilon;\nverbose=false: whether to print intermediate progress reports.\n\n\n\n\n\n","category":"function"},{"location":"Laplace/#CoherentStructures.sparse_diff_op","page":"Graph Laplacian-based methods","title":"CoherentStructures.sparse_diff_op","text":"sparse_diff_op(data, sp_method, kernel; α=1, metric=Euclidean()) -> SparseMatrixCSC\n\nReturn a sparse diffusion/Markov matrix P.\n\nArguments\n\ndata: a list of trajectories, each a list of states of type SVector, or a list of states of type SVector;\nsp_method: a sparsification method;\nkernel: diffusion kernel, e.g., gaussian;\n\nKeyword arguments\n\nα: exponent in diffusion-map normalization;\nmetric: distance function w.r.t. which the kernel is computed, however, only for point pairs where metric(x_i x_j)leq varepsilon.\n\n\n\n\n\n","category":"function"},{"location":"Laplace/#Normalization-functions-1","page":"Graph Laplacian-based methods","title":"Normalization functions","text":"","category":"section"},{"location":"Laplace/#","page":"Graph Laplacian-based methods","title":"Graph Laplacian-based methods","text":"In the diffusion maps framework, there are two commonly used normalization steps:","category":"page"},{"location":"Laplace/#","page":"Graph Laplacian-based methods","title":"Graph Laplacian-based methods","text":"kernel-density estimate normalization (kde_normalize!), and\nrow normalization (row_normalize!), to obtain a diffusion/Markov operator (w.r.t. right- and left-action, respectively).","category":"page"},{"location":"Laplace/#","page":"Graph Laplacian-based methods","title":"Graph Laplacian-based methods","text":"kde_normalize!\nrow_normalize!","category":"page"},{"location":"Laplace/#CoherentStructures.kde_normalize!","page":"Graph Laplacian-based methods","title":"CoherentStructures.kde_normalize!","text":"kde_normalize!(A, α=1)\n\nNormalize rows and columns of A in-place with the respective row-sum to the α-th power; i.e., return a_ij=a_ijq_i^alphaq_j^alpha, where q_k = sum_ell a_kell. Default for α is 1.\n\n\n\n\n\n","category":"function"},{"location":"Laplace/#CoherentStructures.row_normalize!","page":"Graph Laplacian-based methods","title":"CoherentStructures.row_normalize!","text":"row_normalize!(A)\n\nNormalize rows of A in-place with the respective row-sum; i.e., return a_ij=a_ijq_i.\n\n\n\n\n\n","category":"function"},{"location":"Laplace/#Diffusion-coordinate-like-functions-1","page":"Graph Laplacian-based methods","title":"Diffusion-coordinate-like functions","text":"","category":"section"},{"location":"Laplace/#","page":"Graph Laplacian-based methods","title":"Graph Laplacian-based methods","text":"diffusion_coordinates\ndiffusion_distance","category":"page"},{"location":"Laplace/#CoherentStructures.diffusion_coordinates","page":"Graph Laplacian-based methods","title":"CoherentStructures.diffusion_coordinates","text":"diffusion_coordinates(P, n_coords; maxiter=3000) -> (Σ, Ψ)\n\nCompute the (time-coupled) diffusion coordinate matrix Ψ and the coordinate weight vector Σ for a diffusion operator P. The argument n_coords determines the number of diffusion  coordinates to be computed, maxiter is passed to Arpack.eigs.\n\n\n\n\n\n","category":"function"},{"location":"Laplace/#CoherentStructures.diffusion_distance","page":"Graph Laplacian-based methods","title":"CoherentStructures.diffusion_distance","text":"diffusion_distance(Ψ)\n\nReturns the symmetric pairwise diffusion distance matrix corresponding to points whose diffusion coordinates are given by Ψ.\n\n\n\n\n\n","category":"function"},{"location":"basics/#Basics-1","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"basics/#","page":"Basics","title":"Basics","text":"CurrentModule = CoherentStructures","category":"page"},{"location":"basics/#Definition-of-vector-fields-1","page":"Basics","title":"Definition of vector fields","text":"","category":"section"},{"location":"basics/#","page":"Basics","title":"Basics","text":"CoherentStructures.jl is set up for handling two- and three-dimensional dynamical systems only. For such low-dimensional flows it is advantageous (for top performance) to obey the following syntax:","category":"page"},{"location":"basics/#","page":"Basics","title":"Basics","text":"function vectorfield2d(u, p, t)\n    du1 = ... # equation for $\\dot{x}$\n    du2 = ... # equation for $\\dot{y}$\n    return StaticArrays.SVector{2}(du1, du2)\nend","category":"page"},{"location":"basics/#","page":"Basics","title":"Basics","text":"and correspondingly for three-dimensional ODEs:","category":"page"},{"location":"basics/#","page":"Basics","title":"Basics","text":"function vectorfield3d(u, p, t)\n    du1 = ... # equation for $\\dot{x}$\n    du2 = ... # equation for $\\dot{y}$\n    du3 = ... # equation for $\\dot{z}$\n    return StaticArrays.SVector{3}(du1, du2, du3)\nend","category":"page"},{"location":"basics/#","page":"Basics","title":"Basics","text":"Furthermore, there are convenience macros to define two-dimensional velocity and vorticity fields from stream functions.","category":"page"},{"location":"basics/#","page":"Basics","title":"Basics","text":"@define_stream\n@velo_from_stream\n@var_velo_from_stream\n@vorticity_from_stream","category":"page"},{"location":"basics/#CoherentStructures.@define_stream","page":"Basics","title":"CoherentStructures.@define_stream","text":"@define_stream(name::Symbol, code::Expr)\n\nDefine a scalar stream function on R^2. The defining code can be a series of definitions in an enclosing begin ... end-block and is treated as a series of symbolic substitutions. Starting from the symbol name, substitutions are performed until the resulting expression only depends on x, y and t.\n\nThe symbol name is not brought into the namespace. To access the resulting vector field and variational equation  use @velo_from_stream name and @var_velo_from_stream name\n\nThis is a convenience macro for the case where you want to use @velo_from_stream and @var_velo_from_stream without typing the code twice. If you only use one, you might as well use @velo_from_stream name code or @var_velo_from_stream directly.\n\n\n\n\n\n","category":"macro"},{"location":"basics/#CoherentStructures.@velo_from_stream","page":"Basics","title":"CoherentStructures.@velo_from_stream","text":"@velo_from_stream(name::Symbol, [code::Expr])\n\nGet the velocity field corresponding to a stream function on R^2. The defining code can be a series of definitions (in an enclosing begin ... end-block and is treated as a series of symbolic substitutions. Starting from the symbol name, substitutions are performed until the resulting expression only depends on x, y and t.\n\nThe macro returns an anonymous function with signature (u,p,t) that returns an SVector{2} corresponding to the vector field at position u at time t. The parameter slot is not used and can be filled with nothing when calling.\n\nThe macro can be called without the code if the stream name has been defined beforehand via @define_stream.\n\nnote: Sign convention\nWe follow the \"oceanographic\" sign convention, whereby the velocity v is derived from the stream function psi by v = (-partial_ypsi partial_xpsi)\n\nExamples\n\njulia> using CoherentStructures\n\njulia> f = @velo_from_stream Ψ_ellipse begin\n               Ψ_ellipse = a*x^2 + b*y^2\n               a = t\n               b = 3\n           end\n(#3) #1 (generic function with 1 method)\n\njulia> f([1.0,1.0], nothing, 1.0)\n2-element StaticArrays.SArray{Tuple{2},Float64,1,2}:\n -6.0\n  2.0\n\njulia> using CoherentStructures\n\njulia> @define_stream Ψ_circular begin\n           Ψ_circular = f(x) + g(y)\n           # naming of function variables\n           # does not matter:\n           f(a) = a^2\n           g(y) = y^2\n       end\n\njulia> f2 = @velo_from_stream Ψ_circular\n(#5) #1 (generic function with 1 method)\n\njulia> f2([1.0,1.0], nothing, 0.0)\n2-element StaticArrays.SArray{Tuple{2},Float64,1,2}:\n -2.0\n  2.0\n\n\n\n\n\n","category":"macro"},{"location":"basics/#CoherentStructures.@var_velo_from_stream","page":"Basics","title":"CoherentStructures.@var_velo_from_stream","text":"@var_velo_from_stream(name::Symbol, [code::Expr])\n\nGet the (state and tangent space) velocity field corresponding to a stream function on R^2. The defining code can be a series of definitions (in an enclosing begin ... end-block and is treated as a series of symbolic substitutions. Starting from the symbol name, substitutions are performed until the resulting expression only depends on x, y and t.\n\nThe macro returns an anonymous function with signature (U,p,t) that returns an SMatrix{2,3}: in the first column, one has the usual velocity, in the second to third column, one has the linearized velocity, both at position u = U[:,1] at time t. The parameter slot is not used and can be filled with nothing when calling.\n\nThe macro can be called without the code if the stream name has been defined beforehand via @define_stream.\n\nnote: Sign convention\nWe follow the \"oceanographic\" sign convention, whereby the velocity v is derived from the stream function psi by v = (-partial_ypsi partial_xpsi)\n\n\n\n\n\n","category":"macro"},{"location":"basics/#CoherentStructures.@vorticity_from_stream","page":"Basics","title":"CoherentStructures.@vorticity_from_stream","text":"@vorticity_from_stream(name::Symbol, [code::Expr])\n\nGet the vorticity field as a function of (x, y, t) corresponding to a stream function on R^2.\n\nnote: Sign convention\nThe vorticity omega of the velocity field v = (v_x v_y) is defined as derived from the stream function psi by omega = partial_x v_x - partial_y v_y) = trace(nabla^2psi), i.e., the trace of the Hessian of the stream function.\n\n\n\n\n\n","category":"macro"},{"location":"basics/#","page":"Basics","title":"Basics","text":"In fact, two of the predefined velocity fields, the rotating double gyre rot_double_gyre, and the Bickley jet flow bickleyJet, are generated from these macros.","category":"page"},{"location":"basics/#","page":"Basics","title":"Basics","text":"Another typical use case is when velocities are given as a data set. In this case, one first interpolates the velocity components with interpolateVF to obtain a callable interpolation function, say, UI. The corresponding vector field is then interp_rhs, into which the velocity interpolant enters via the parameter argument p; see below for examples.","category":"page"},{"location":"basics/#","page":"Basics","title":"Basics","text":"interpolateVF\ninterp_rhs\ninterp_rhs!","category":"page"},{"location":"basics/#CoherentStructures.interpolateVF","page":"Basics","title":"CoherentStructures.interpolateVF","text":"interpolateVF(xspan, yspan, tspan, u, v, itp_type=ITP.BSpline(ITP.Cubic(ITP.Free())))) -> VI\n\nxspan, yspan and tspan span the space-time domain on which the velocity-components u and v are given. u corresponds to the x- or eastward component, v corresponds to the y- or northward component. For interpolation, the Interpolations.jl package is used; see their documentation for how to declare other interpolation types.\n\nUsage\n\njulia> uv = interpolateVF(xs, ys, ts, u, v)\n\njulia> uv(x, y, t)\n2-element SArray{Tuple{2},Float64,1,2} with indices SOneTo(2):\n -44.23554926984537\n  -4.964069022198859\n\n\n\n\n\n","category":"function"},{"location":"basics/#CoherentStructures.interp_rhs","page":"Basics","title":"CoherentStructures.interp_rhs","text":"interp_rhs(u, p, t) -> SVector{2}\n\nDefines an out-of-place 2D vector field that is readily usable for trajectory integration from a vector field interpolant. It assumes that the interpolant is provided via the parameter p, usually in the flow or tensor functions.\n\nExample\n\njulia> UI = interpolateVF(X, Y, T, U, V)\n\njulia> f = u -> flow(interp_rhs, u, tspan; p=UI)\n\njulia> mCG_tensor = u -> CG_tensor(interp_rhs, u, tspan, δ; p=UI)\n\n\n\n\n\n","category":"function"},{"location":"basics/#CoherentStructures.interp_rhs!","page":"Basics","title":"CoherentStructures.interp_rhs!","text":"interp_rhs!(du, u, p, t) -> Vector\n\nDefines a mutating/inplace 2D vector field that is readily usable for trajectory integration from a vector field interpolant. It assumes that the interpolant is provided via the parameter p.\n\nExample\n\njulia> UI = interpolateVF(X, Y, T, U, V)\n\njulia> f = u -> flow(interp_rhs!, u, tspan; p=UI)\n\njulia> mCG_tensor = u -> CG_tensor(interp_rhs!, u, tspan, δ; p=UI)\n\n\n\n\n\n","category":"function"},{"location":"basics/#(Linearized)-Flow-map-1","page":"Basics","title":"(Linearized) Flow map","text":"","category":"section"},{"location":"basics/#","page":"Basics","title":"Basics","text":"flow\nlinearized_flow","category":"page"},{"location":"basics/#CoherentStructures.flow","page":"Basics","title":"CoherentStructures.flow","text":"flow(odefun,  u0, tspan; p, solver, tolerance, force_dtmin)\n\nSolve the ODE with right hand side given by odefun and initial value u0 over the time interval tspan, evaluated at each element of tspan.\n\nKeyword arguments\n\np: parameter that is passed to odefun, e.g., in interp_rhs;\nsolver=OrdinaryDiffEq.BS5(): ODE solver;\ntolerance=1e-3: relative and absolute tolerance for ODE integration;\nforce_dtmin=false: force the ODE solver to step forward with dtmin, even if the adaptive scheme would reject the step.\n\nExample\n\njulia> f = u -> flow((u, p, t) -> vf(u, p, t), u, range(0., stop=100, length=21))\n\n\n\n\n\n","category":"function"},{"location":"basics/#CoherentStructures.linearized_flow","page":"Basics","title":"CoherentStructures.linearized_flow","text":"linearized_flow(odefun, x, tspan, δ; kwargs...)\n\nCalculate derivative of flow map by finite differencing (if δ != 0) or by solving the variational equation (if δ = 0).\n\nReturn the time-resolved base trajectory and its associated linearized flow maps.\n\n\n\n\n\n","category":"function"},{"location":"basics/#Cauchy-Green-and-other-pullback-tensors-1","page":"Basics","title":"Cauchy-Green and other pullback tensors","text":"","category":"section"},{"location":"basics/#","page":"Basics","title":"Basics","text":"CG_tensor\nmean_diff_tensor\nav_weighted_CG_tensor\npullback_tensors\npullback_metric_tensor\npullback_diffusion_tensor\npullback_SDE_diffusion_tensor","category":"page"},{"location":"basics/#CoherentStructures.CG_tensor","page":"Basics","title":"CoherentStructures.CG_tensor","text":"CG_tensor(odefun, u, tspan, δ; kwargs...) -> SymmetricTensor\n\nReturns the classic right Cauchy–Green strain tensor. Linearized flow maps are computed with linearized_flow, see its documentation for the meaning of δ.\n\nodefun: RHS of the ODE\nu: initial value of the ODE\ntspan: set of time instances at which to save the trajectory\nδ: stencil width for the finite differences, see linearized_flow\nkwargs: are passed to linearized_flow\n\n\n\n\n\n","category":"function"},{"location":"basics/#CoherentStructures.mean_diff_tensor","page":"Basics","title":"CoherentStructures.mean_diff_tensor","text":"mean_diff_tensor(odefun, u, tspan, δ; kwargs...) -> SymmetricTensor\n\nReturn the averaged diffusion tensor at a point along a set of times. Linearized flow maps are computed with linearized_flow, see its documentation for the meaning of δ.\n\nodefun: RHS of the ODE\nu: initial value of the ODE\ntspan: set of time instances at which to save the trajectory\nδ: stencil width for the finite differences, see linearized_flow\nkwargs: are passed to linearized_flow\n\n\n\n\n\n","category":"function"},{"location":"basics/#CoherentStructures.av_weighted_CG_tensor","page":"Basics","title":"CoherentStructures.av_weighted_CG_tensor","text":"av_weighted_CG_tensor(odefun, u, tspan, δ; D, kwargs...) -> SymmetricTensor\n\nReturns the transport tensor of a trajectory, aka  time-averaged, di\u0000ffusivity-structure-weighted version of the classic right Cauchy–Green strain tensor. Linearized flow maps are computed with linearized_flow, see its documentation for the meaning of δ.\n\nodefun: RHS of the ODE\nu: initial value of the ODE\ntspan: set of time instances at which to save the trajectory\nδ: stencil width for the finite differences, see linearized_flow\nD: (constant) diffusion tensor\nkwargs... are passed through to linearized_flow\n\n\n\n\n\n","category":"function"},{"location":"basics/#CoherentStructures.pullback_tensors","page":"Basics","title":"CoherentStructures.pullback_tensors","text":"pullback_tensors(odefun, u, tspan, δ; D, kwargs...) -> Tuple(Vector{SymmetricTensor},Vector{SymmetricTensor})\n\nReturns the time-resolved pullback tensors of both the diffusion and the metric tensor along a trajectory. Linearized flow maps are computed with linearized_flow, see its documentation for the meaning of δ.\n\nodefun: RHS of the ODE\nu: initial value of the ODE\ntspan: set of time instances at which to save the trajectory\nδ: stencil width for the finite differences, see linearized_flow\nD: (constant) diffusion tensor, metric tensor is computed via inversion; defaults to identity tensor\nkwargs are passed to linearized_flow\n\n\n\n\n\n","category":"function"},{"location":"basics/#CoherentStructures.pullback_metric_tensor","page":"Basics","title":"CoherentStructures.pullback_metric_tensor","text":"pullback_metric_tensor(odefun, u, tspan, δ; G, kwargs...) -> Vector{SymmetricTensor}\n\nReturns the time-resolved pullback tensors of the metric tensor along a trajectory, aka right Cauchy-Green strain tensor. Linearized flow maps are computed with linearized_flow, see its documentation for the meaning of δ.\n\nodefun: RHS of the ODE\nu: initial value of the ODE\ntspan: set of time instances at which to save the trajectory\nδ: stencil width for the finite differences, see linearized_flow\nG: (constant) metric tensor\nkwargs... are passed through to linearized_flow\n\n\n\n\n\n","category":"function"},{"location":"basics/#CoherentStructures.pullback_diffusion_tensor","page":"Basics","title":"CoherentStructures.pullback_diffusion_tensor","text":"pullback_diffusion_tensor(odefun, u, tspan, δ; D, kwargs...) -> Vector{SymmetricTensor}\n\nReturns the time-resolved pullback tensors of the diffusion tensor along a trajectory. Linearized flow maps are computed with linearized_flow, see its documentation for the meaning of δ.\n\nodefun: RHS of the ODE\nu: initial value of the ODE\ntspan: set of time instances at which to save the trajectory\nδ: stencil width for the finite differences, see linearized_flow\nD: (constant) diffusion tensor\nkwargs... are passed through to linearized_flow\n\n\n\n\n\n","category":"function"},{"location":"basics/#CoherentStructures.pullback_SDE_diffusion_tensor","page":"Basics","title":"CoherentStructures.pullback_SDE_diffusion_tensor","text":"pullback_SDE_diffusion_tensor(odefun, u, tspan, δ; B, kwargs...) -> Vector{SymmetricTensor}\n\nReturns the time-resolved pullback tensors of the diffusion tensor in SDEs. Linearized flow maps are computed with linearized_flow, see its documentation for the meaning of δ.\n\nodefun: RHS of the ODE\nu: initial value of the ODE\ntspan: set of time instances at which to save the trajectory\nδ: stencil width for the finite differences, see linearized_flow\nB: (constant) SDE tensor\nkwargs... are passed through to linearized_flow\n\n\n\n\n\n","category":"function"},{"location":"basics/#","page":"Basics","title":"Basics","text":"A second-order symmetric two-dimensional tensor (field) may be diagonalized (pointwise), ie., an eigendecomposition is computed, by the following function.","category":"page"},{"location":"basics/#","page":"Basics","title":"Basics","text":"tensor_invariants","category":"page"},{"location":"basics/#CoherentStructures.tensor_invariants","page":"Basics","title":"CoherentStructures.tensor_invariants","text":"tensor_invariants(T) -> λ₁, λ₂, ξ₁, ξ₂, traceT, detT\n\nReturns pointwise invariants of the 2D symmetric tensor field T, i.e., smallest and largest eigenvalues, corresponding eigenvectors, trace and determinant.\n\nExample\n\nT = [SymmetricTensor{2,2}(rand(3)) for i in 1:10, j in 1:20]\nλ₁, λ₂, ξ₁, ξ₂, traceT, detT = tensor_invariants(T)\n\nAll output variables have the same array arrangement as T; e.g., λ₁ is a 10x20 array with scalar entries.\n\n\n\n\n\n","category":"function"},{"location":"basics/#Distance-computations-1","page":"Basics","title":"Distance computations","text":"","category":"section"},{"location":"basics/#","page":"Basics","title":"Basics","text":"For computing distances w.r.t. standard metrics, there exists the excellent Distance.jl package. For example, the Euclidean distance between two points is computed by any of the last two lines:","category":"page"},{"location":"basics/#","page":"Basics","title":"Basics","text":"using Distances\nx, y = rand(3), rand(3)\nevaluate(Euclidean(), x, y)\neuclidean(x, y)","category":"page"},{"location":"basics/#","page":"Basics","title":"Basics","text":"Other metrics of potential interest include Haversine(r), the geodesic distance of two points on the sphere with radius r, and PeriodicEuclidean(L), the distance on a torus or cylinder. Here, L is a vector containing the period of each dimension, Inf for non-periodic dimensions.","category":"page"},{"location":"basics/#","page":"Basics","title":"Basics","text":"Distances.Euclidean\nDistances.Haversine\nDistances.PeriodicEuclidean","category":"page"},{"location":"basics/#Distances.Euclidean","page":"Basics","title":"Distances.Euclidean","text":"Euclidean([thresh])\n\nCreate a euclidean metric.\n\nWhen computing distances among large numbers of points, it can be much more efficient to exploit the formula\n\n(x-y)^2 = x^2 - 2xy + y^2\n\nHowever, this can introduce roundoff error. thresh (which defaults to 0) specifies the relative square-distance tolerance on 2xy compared to x^2 + y^2 to force recalculation of the distance using the more precise direct (elementwise-subtraction) formula.\n\nExample:\n\njulia> x = reshape([0.1, 0.3, -0.1], 3, 1);\n\njulia> pairwise(Euclidean(), x, x)\n1×1 Array{Float64,2}:\n 7.45058e-9\n\njulia> pairwise(Euclidean(1e-12), x, x)\n1×1 Array{Float64,2}:\n 0.0\n\n\n\n\n\n","category":"type"},{"location":"basics/#Distances.Haversine","page":"Basics","title":"Distances.Haversine","text":"Haversine(radius)\n\nThe haversine distance between two locations on a sphere of given radius.\n\nLocations are described with longitude and latitude in degrees. The computed distance has the same units as that of the radius.\n\n\n\n\n\n","category":"type"},{"location":"basics/#Distances.PeriodicEuclidean","page":"Basics","title":"Distances.PeriodicEuclidean","text":"    PeriodicEuclidean(L)\n\nCreate a Euclidean metric on a rectangular periodic domain (i.e., a torus or a cylinder). Periods per dimension are contained in the vector L:\n\nsqrtsum_i(minmod(x_i - y_i p) p - mod(x_i - y_i p))^2\n\nFor dimensions without periodicity put Inf in the respective component.\n\nExample\n\njulia> x, y, L = [0.0, 0.0], [0.75, 0.0], [0.5, Inf];\n\njulia> evaluate(PeriodicEuclidean(L), x, y)\n0.25\n\n\n\n\n\n","category":"type"},{"location":"basics/#","page":"Basics","title":"Basics","text":"In CoherentStructures.jl, there is one more metric type implemented:","category":"page"},{"location":"basics/#","page":"Basics","title":"Basics","text":"STmetric","category":"page"},{"location":"basics/#CoherentStructures.STmetric","page":"Basics","title":"CoherentStructures.STmetric","text":"STmetric(metric, p)\n\nCreates a spatiotemporal, averaged-in-time metric. At each time instance, the distance between two states a and b is computed via evaluate(metric, a, b). The resulting distances are subsequently ℓ^p-averaged, with p= p.\n\nFields\n\nmetric=Euclidean(): a SemiMetric as defined in the Distances.jl package,\n\ne.g., Euclidean,    PeriodicEuclidean, or    Haversine;       * p = Inf: maximum       * p = 2: mean squared average       * p = 1: arithmetic mean       * p = -1: harmonic mean (does not yield a metric!)       * p = -Inf: minimum (does not yield a metric!)\n\nExample\n\njulia> x = [@SVector rand(2) for _ in 1:10];\n\njulia> STmetric(Euclidean(), 1) # Euclidean distances arithmetically averaged\nSTmetric{Euclidean,Int64}(Euclidean(0.0), 1)\n\njulia> evaluate(STmetric(Euclidean(), 1), x, x)\n0.0\n\n\n\n\n\n","category":"type"},{"location":"basics/#","page":"Basics","title":"Basics","text":"That is a spatiotemporal metric that operates on trajectories in the format of vectors of static vectors, i.e., Vector{<:SVector}. Each vector element corresponds to the state vector. The STmetric then computes the l_p-mean of the spatial distances over time. Notably, p may be any \"real\" number, including Inf and -Inf for the maximum- and \"minimum\"-norm.","category":"page"},{"location":"generated/standard_map/#","page":"Standard map","title":"Standard map","text":"  EditURL = \"../../examples/standard_map.jl\"","category":"page"},{"location":"generated/standard_map/#The-standard-map-1","page":"Standard map","title":"The standard map","text":"","category":"section"},{"location":"generated/standard_map/#","page":"Standard map","title":"Standard map","text":"tip: Tip\nThis example is also available as a Jupyter notebook: standard_map.ipynb, and as an executable julia file standard_map.jl.","category":"page"},{"location":"generated/standard_map/#","page":"Standard map","title":"Standard map","text":"The standard map","category":"page"},{"location":"generated/standard_map/#","page":"Standard map","title":"Standard map","text":"f(xy) = (x+y+asin(x)y+asin(x))","category":"page"},{"location":"generated/standard_map/#","page":"Standard map","title":"Standard map","text":"is an area-preserving map on the 2-torus 02pi^2 resulting from a symplectic time-discretization of the planar pendulum.  For a = 0971635, its phase space shows the characteristic mixture of regular (periodic or quasi-periodic) and chaotic motion.  Here, we repeat the experiment in Froyland & Junge (2015) and compute coherent structures.","category":"page"},{"location":"generated/standard_map/#","page":"Standard map","title":"Standard map","text":"We first visualize the phase space by plotting 500 iterates of 50 random seed points.","category":"page"},{"location":"generated/standard_map/#","page":"Standard map","title":"Standard map","text":"using Random\n\nconst a = 0.971635\nf(x) = (rem2pi(x[1] + x[2] + a*sin(x[1]), RoundDown),\n          rem2pi(x[2] + a*sin(x[1]), RoundDown))\n\nX = Tuple{Float64,Float64}[]\nfor i in 1:50\n    Random.seed!(i)\n    x = 2π .* (rand(), rand())\n    for i in 1:500\n        x = f(x)\n        push!(X,x)\n    end\nend\n\nusing Plots\ngr(aspect_ratio=1, legend=:none)\nfig = scatter(X, markersize=1)","category":"page"},{"location":"generated/standard_map/#","page":"Standard map","title":"Standard map","text":"(Image: )","category":"page"},{"location":"generated/standard_map/#","page":"Standard map","title":"Standard map","text":"Approximating the Dynamic Laplacian by FEM methods is straightforward:","category":"page"},{"location":"generated/standard_map/#","page":"Standard map","title":"Standard map","text":"using Arpack, CoherentStructures, Distances, Tensors\n\nDf(x) = Tensor{2,2}((1.0+a*cos(x[1]), a*cos(x[1]), 1.0, 1.0))\n\nn, ll, ur = 100, (0.0, 0.0), (2π, 2π)       # grid size, domain corners\nctx, _ = regularTriangularGrid((n, n), ll, ur)\npred(x,y) = peuclidean(x, y, [2π, 2π]) < 1e-9\nbd = BoundaryData(ctx, pred)                # periodic boundary\n\nI = one(Tensor{2,2})                        # identity matrix\nDf2(x) = Df(f(x))⋅Df(x)                     # consider 2. iterate\ncg(x) = 0.5*(I + dott(inv(Df2(x))))         # avg. inv. Cauchy-Green tensor\n\nK = assembleStiffnessMatrix(ctx, cg, bdata=bd)\nM = assembleMassMatrix(ctx, bdata=bd)\nλ, v = eigs(K, M, which=:SM)\n\nusing Printf\ntitle = [ @sprintf(\"\\\\lambda = %.3f\", λ[i]) for i = 1:4 ]\np = [ plot_u(ctx, v[:,i], bdata=bd, title=title[i],\n             clim=(-0.25, 0.25), cb=false) for i in 1:4 ]\nfig = plot(p...)","category":"page"},{"location":"generated/standard_map/#","page":"Standard map","title":"Standard map","text":"(Image: )","category":"page"},{"location":"generated/standard_map/#","page":"Standard map","title":"Standard map","text":"","category":"page"},{"location":"generated/standard_map/#","page":"Standard map","title":"Standard map","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/bickley/#","page":"Bickley jet","title":"Bickley jet","text":"  EditURL = \"../../examples/bickley.jl\"","category":"page"},{"location":"generated/bickley/#Bickley-jet-1","page":"Bickley jet","title":"Bickley jet","text":"","category":"section"},{"location":"generated/bickley/#","page":"Bickley jet","title":"Bickley jet","text":"tip: Tip\nThis example is also available as a Jupyter notebook: bickley.ipynb, and as an executable julia file bickley.jl.","category":"page"},{"location":"generated/bickley/#","page":"Bickley jet","title":"Bickley jet","text":"The Bickley jet flow is a kinematic idealized model of a meandering zonal jet flanked above and below by counterrotating vortices. It was introduced by Rypina et al.; cf. also del‐Castillo‐Negrete and Morrison.","category":"page"},{"location":"generated/bickley/#","page":"Bickley jet","title":"Bickley jet","text":"The Bickley jet is described by a time-dependent velocity field arising from a stream-function. The corresponding velocity field is provided by the package and callable as bickleyJet.","category":"page"},{"location":"generated/bickley/#","page":"Bickley jet","title":"Bickley jet","text":"Instead of using the bickleyJet function to get this velocity field, we could also use the @velo_from_stream macro:","category":"page"},{"location":"generated/bickley/#","page":"Bickley jet","title":"Bickley jet","text":"using CoherentStructures\nbickley = @velo_from_stream stream begin\n    stream = psi₀ + psi₁\n    psi₀   = - U₀ * L₀ * tanh(y / L₀)\n    psi₁   =   U₀ * L₀ * sech(y / L₀)^2 * re_sum_term\n\n    re_sum_term =  Σ₁ + Σ₂ + Σ₃\n\n    Σ₁  =  ε₁ * cos(k₁*(x - c₁*t))\n    Σ₂  =  ε₂ * cos(k₂*(x - c₂*t))\n    Σ₃  =  ε₃ * cos(k₃*(x - c₃*t))\n\n    k₁ = 2/r₀      ; k₂ = 4/r₀    ; k₃ = 6/r₀\n\n    ε₁ = 0.0075    ; ε₂ = 0.15    ; ε₃ = 0.3\n    c₂ = 0.205U₀   ; c₃ = 0.461U₀ ; c₁ = c₃ + (√5-1)*(c₂-c₃)\n\n    U₀ = 62.66e-6  ; L₀ = 1770e-3 ; r₀ = 6371e-3\nend","category":"page"},{"location":"generated/bickley/#","page":"Bickley jet","title":"Bickley jet","text":"Now, bickley is a callable function with the standard OrdinaryDiffEq signature (u, p, t) with state u, (unused) parameter p and time t.","category":"page"},{"location":"generated/bickley/#Geodesic-vortices-1","page":"Bickley jet","title":"Geodesic vortices","text":"","category":"section"},{"location":"generated/bickley/#","page":"Bickley jet","title":"Bickley jet","text":"Here we briefly demonstrate how to find material barriers to diffusive transport; see Geodesic elliptic material vortices for references and details.","category":"page"},{"location":"generated/bickley/#","page":"Bickley jet","title":"Bickley jet","text":"using Distributed\nnprocs() == 1 && addprocs()\n\n@everywhere using CoherentStructures, OrdinaryDiffEq, Tensors\nusing StaticArrays, AxisArrays\nq = 81\ntspan = range(0., stop=3456000., length=q)\nny = 61\nnx = (22ny) ÷ 6\nxmin, xmax, ymin, ymax = 0.0 - 2.0, 6.371π + 2.0, -3.0, 3.0\nxspan = range(xmin, stop=xmax, length=nx)\nyspan = range(ymin, stop=ymax, length=ny)\nP = AxisArray(SVector{2}.(xspan, yspan'), xspan, yspan)\nδ = 1.e-6\nD = SymmetricTensor{2,2}([2., 0., 1/2])\nmCG_tensor = let tspan=tspan, δ=δ, D=D\n    u -> av_weighted_CG_tensor(bickleyJet, u, tspan, δ;\n          D=D, tolerance=1e-6, solver=Tsit5())\nend\n\nC̅ = pmap(mCG_tensor, P; batch_size=ceil(Int, length(P)/nprocs()^2))\np = LCSParameters(2.0)\nvortices, singularities = ellipticLCS(C̅, p)","category":"page"},{"location":"generated/bickley/#","page":"Bickley jet","title":"Bickley jet","text":"The result is visualized as follows:","category":"page"},{"location":"generated/bickley/#","page":"Bickley jet","title":"Bickley jet","text":"using Plots\ntrace = tensor_invariants(C̅)[5]\nfig = plot_vortices(vortices, singularities, (xmin, ymin), (xmax, ymax);\n    bg=trace, title=\"DBS field and transport barriers\", showlabel=true)","category":"page"},{"location":"generated/bickley/#","page":"Bickley jet","title":"Bickley jet","text":"(Image: )","category":"page"},{"location":"generated/bickley/#FEM-based-Methods-1","page":"Bickley jet","title":"FEM-based Methods","text":"","category":"section"},{"location":"generated/bickley/#","page":"Bickley jet","title":"Bickley jet","text":"Assume we have setup the bickley function using the @velo_from_stream macro as described above. We are working on a periodic domain in one direction:","category":"page"},{"location":"generated/bickley/#","page":"Bickley jet","title":"Bickley jet","text":"using Distances\nLL = (0.0, -3.0); UR = (6.371π, 3.0)\nctx, _ = regularP2TriangularGrid((50, 15), LL, UR, quadrature_order=2)\npredicate = (p1, p2) -> peuclidean(p1, p2, [6.371π, Inf]) < 1e-10\nbdata = BoundaryData(ctx, predicate, []);","category":"page"},{"location":"generated/bickley/#","page":"Bickley jet","title":"Bickley jet","text":"Using a FEM-based method to compute coherent structures:","category":"page"},{"location":"generated/bickley/#","page":"Bickley jet","title":"Bickley jet","text":"using Arpack\ncgfun = (x -> mean_diff_tensor(bickley, x, range(0.0, stop=40*3600*24, length=81),\n     1.e-8; tolerance=1.e-5))\n\nK = assembleStiffnessMatrix(ctx, cgfun, bdata=bdata)\nM = assembleMassMatrix(ctx, bdata=bdata)\nλ, v = eigs(K, M, which=:SM, nev= 10)\n\nimport Plots\nfig_spectrum = plot_real_spectrum(λ)","category":"page"},{"location":"generated/bickley/#","page":"Bickley jet","title":"Bickley jet","text":"(Image: )","category":"page"},{"location":"generated/bickley/#","page":"Bickley jet","title":"Bickley jet","text":"K-means clustering yields the coherent vortices.","category":"page"},{"location":"generated/bickley/#","page":"Bickley jet","title":"Bickley jet","text":"using Clustering\nctx2, _ = regularTriangularGrid((200, 60), LL, UR)\nv_upsampled = sample_to(v, ctx, ctx2, bdata=bdata)\n\nfunction iterated_kmeans(numiterations, args...)\n    best = kmeans(args...)\n    for i in 1:(numiterations - 1)\n        cur = kmeans(args...)\n        if cur.totalcost < best.totalcost\n            best = cur\n        end\n    end\n    return best\nend\n\nn_partition = 8\nres = iterated_kmeans(20, permutedims(v_upsampled[:,2:n_partition]), n_partition)\nu = kmeansresult2LCS(res)\nu_combined = sum([u[:,i] * i for i in 1:n_partition])\nfig = plot_u(ctx2, u_combined, 400, 400;\n    color=:rainbow, colorbar=:none, title=\"$n_partition-partition of Bickley jet\")","category":"page"},{"location":"generated/bickley/#","page":"Bickley jet","title":"Bickley jet","text":"(Image: )","category":"page"},{"location":"generated/bickley/#","page":"Bickley jet","title":"Bickley jet","text":"","category":"page"},{"location":"generated/bickley/#","page":"Bickley jet","title":"Bickley jet","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"  EditURL = \"../../examples/rot_double_gyre.jl\"","category":"page"},{"location":"generated/rot_double_gyre/#Rotating-double-gyre-1","page":"Rotating double gyre","title":"Rotating double gyre","text":"","category":"section"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"tip: Tip\nThis example is also available as a Jupyter notebook: rot_double_gyre.ipynb, and as an executable julia file rot_double_gyre.jl.","category":"page"},{"location":"generated/rot_double_gyre/#Description-1","page":"Rotating double gyre","title":"Description","text":"","category":"section"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"The rotating double gyre model was introduced by Mosovsky & Meiss. It can be derived from the stream function","category":"page"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"psi(xyt)=(1s(t))psi_P +s(t)psi_F  psi_P (x y) = sin(2pi x) sin(pi y)  psi_F (x y) = sin(pi x) sin(2pi y)","category":"page"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"where s is (usually taken to be) a cubic interpolating function satisfying s(0) = 0 and s(1) = 1. It therefore interpolates two double-gyre-type velocity fields, from horizontally to vertically arranged counter-rotating gyres. The corresponding velocity field is provided by the package and callable as rot_double_gyre.","category":"page"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"(Image: )","category":"page"},{"location":"generated/rot_double_gyre/#FEM-Based-Methods-1","page":"Rotating double gyre","title":"FEM-Based Methods","text":"","category":"section"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"The following code demonstrates how to use these methods.","category":"page"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"using CoherentStructures, Arpack\nLL, UR = (0.0, 0.0), (1.0, 1.0)\nctx, _ = regularTriangularGrid((50, 50), LL, UR)\n\nA = x -> mean_diff_tensor(rot_double_gyre, x, [0.0, 1.0], 1.e-10, tolerance= 1.e-4)\nK = assembleStiffnessMatrix(ctx, A)\nM = assembleMassMatrix(ctx)\nλ, v = eigs(-K, M, which=:SM);","category":"page"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"This velocity field is given by the rot_double_gyre function. The third argument to mean_diff_tensor is a vector of time instances at which we evaluate (and subsequently average) the pullback diffusion tensors. The fourth parameter is the step size δ used for the finite-difference scheme, tolerance is passed to the ODE solver from DifferentialEquations.jl. In the above, A(x) approximates the mean diffusion tensor given by","category":"page"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"A(x) = sum_t in mathcal T(DPhi^t(x))^-1 (DPhi^t x)^-T","category":"page"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"The eigenfunctions saved in v approximate those of Delta^dyn","category":"page"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"import Plots\nres = [plot_u(ctx, v[:,i], 100, 100, colorbar=:none, clim=(-3,3)) for i in 1:6];\nfig = Plots.plot(res..., margin=-10Plots.px)","category":"page"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"(Image: )","category":"page"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"Looking at the spectrum, there appears a gap after the third eigenvalue.","category":"page"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"spectrum_fig = Plots.scatter(1:6, real.(λ))","category":"page"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"(Image: )","category":"page"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"We can use the Clustering.jl package to compute coherent structures from the first two nontrivial eigenfunctions:","category":"page"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"using Clustering\n\nctx2, _ = regularTriangularGrid((200, 200))\nv_upsampled = sample_to(v, ctx, ctx2)\n\nnumclusters=2\nres = kmeans(permutedims(v_upsampled[:,2:numclusters+1]), numclusters + 1)\nu = kmeansresult2LCS(res)\nres = Plots.plot([plot_u(ctx2, u[:,i], 200, 200, color=:viridis, colorbar=:none) for i in 1:3]...)","category":"page"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"(Image: )","category":"page"},{"location":"generated/rot_double_gyre/#Geodesic-vortices-1","page":"Rotating double gyre","title":"Geodesic vortices","text":"","category":"section"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"Here, we demonstrate how to calculate black-hole vortices, see Geodesic elliptic material vortices for references and details.","category":"page"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"using Distributed\nnprocs() == 1 && addprocs()\n\n@everywhere using CoherentStructures, OrdinaryDiffEq\nusing StaticArrays, AxisArrays\nq = 21\ntspan = range(0., stop=1., length=q)\nnx = ny = 101\nxmin, xmax, ymin, ymax = 0.0, 1.0, 0.0, 1.0\nxspan = range(xmin, stop=xmax, length=nx)\nyspan = range(ymin, stop=ymax, length=ny)\nP = AxisArray(SVector{2}.(xspan, yspan'), xspan, yspan)\nδ = 1.e-6\nmCG_tensor = let tspan=tspan, δ=δ\n    u -> av_weighted_CG_tensor(rot_double_gyre, u, tspan, δ; tolerance=1e-6, solver=Tsit5())\nend\n\nC̅ = pmap(mCG_tensor, P; batch_size=ceil(Int, length(P)/nprocs()^2))\np = LCSParameters(0.5)\nvortices, singularities = ellipticLCS(C̅, p; outermost=true)","category":"page"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"The results are then visualized as follows.","category":"page"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"using Plots\ntrace = tensor_invariants(C̅)[5]\nfig = plot_vortices(vortices, singularities, (xmin, ymin), (xmax, ymax);\n    bg=trace, title=\"DBS field and transport barriers\", showlabel=true, clims=(0,5))","category":"page"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"(Image: )","category":"page"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"","category":"page"},{"location":"generated/rot_double_gyre/#","page":"Rotating double gyre","title":"Rotating double gyre","text":"This page was generated using Literate.jl.","category":"page"},{"location":"elliptic/#Geodesic-elliptic-material-vortices-1","page":"Geodesic vortices","title":"Geodesic elliptic material vortices","text":"","category":"section"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"CurrentModule = CoherentStructures","category":"page"},{"location":"elliptic/#Background-1","page":"Geodesic vortices","title":"Background","text":"","category":"section"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"The following functions implement an LCS methodology developed in the following papers:","category":"page"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"Haller & Beron-Vera, 2012\nHaller & Beron-Vera, 2013\nKarrasch, Huhn, and Haller, 2015","category":"page"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"Our implementation here follows conceptually Karrasch, Huhn, and Haller, 2015, and is described in detail in the preprint TBD. Depending on the indefinite metric tensor field used, the functions below yield the following types of coherent structures:","category":"page"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"black-hole/Lagrangian coherent vortices (Haller & Beron-Vera, 2012)\nelliptic objective Eulerian coherent structures (OECSs) (Serra & Haller, 2016)\nmaterial diffusive transport barriers (Haller, Karrasch, and Kogelbauer, 2018)","category":"page"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"The general procedure is the following. Assume T is the symmetric tensor field of interest, say, (i) the Cauchy-Green strain tensor field C, (ii) the rate-of-strain tensor field S, or (iii) the averaged diffusion-weighted Cauchy-Green tensor field barC_D; cf. the references above. Denote by 0lambda_1leqlambda_2 the eigenvalue and by xi_1 and xi_2 the corresponding eigenvector fields of T. Then the direction fields of interest are given by","category":"page"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"eta_lambda^pm = sqrtfraclambda_2 - lambdalambda_2-lambda_1xi_1 pm sqrtfraclambda - lambda_1lambda_2-lambda_1xi_2","category":"page"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"Tensor singularities are defined as points at which lambda_2=lambda_1, i.e., at which the two characteristic directions xi_1 and xi_2 are not well-defined. As described and exploited in Karrasch et al., 2015, non-negligible tensor singularities express themselves by an angle gap when tracking (the angle of) tensor eigenvector fields along closed paths surrounding the singularity. Our approach here avoids computing singularities directly, but rather computes the index for each grid cell and then combines nearby singularities, i.e., adds non-vanishing indices of nearby grid cells.","category":"page"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"In summary, the implementation consists of the following steps:","category":"page"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"compute the index for each grid cell and combine nearby singular grid cells to \"singularity candidates\";\nlook for elliptic singularity candidates (and potentially isolated wedge pairs);\nplace an eastwards oriented Poincaré section at the pair center;\nfor each point on the discretized Poincaré section, scan through the given parameter interval such that the corresponding η-orbit closes at that point;\nif desired: for each Poincaré section, take the outermost closed orbit as the coherent vortex barrier (if there exist any).","category":"page"},{"location":"elliptic/#Function-documentation-1","page":"Geodesic vortices","title":"Function documentation","text":"","category":"section"},{"location":"elliptic/#The-meta-functions-ellipticLCS-and-constrainedLCS-1","page":"Geodesic vortices","title":"The meta-functions ellipticLCS and constrainedLCS","text":"","category":"section"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"The fully automated high-level functions are:","category":"page"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"ellipticLCS","category":"page"},{"location":"elliptic/#CoherentStructures.ellipticLCS","page":"Geodesic vortices","title":"CoherentStructures.ellipticLCS","text":"ellipticLCS(T::AbstractArray, xspan, yspan, p; kwargs...)\nellipticLCS(T::AxisArray, p; kwargs...)\n\nComputes elliptic LCSs as null-geodesics of the Lorentzian metric tensor field given by shifted versions of T on the 2D computational grid spanned by xspan and yspan. p is a LCSParameters-type container of computational parameters. Returns a list of EllipticBarrier-type objects.\n\nThe keyword arguments and their default values are:\n\noutermost=true: only the outermost barriers, i.e., the vortex   boundaries are returned, otherwise all detected transport barrieres;\nverbose=true: show intermediate computational information;\ndebug=false: whether to use the debug mode, which avoids parallelization   for more precise error messages.\nsingularity_predicate = nothing: provide an optional callback to reject certain singularity candidates.\n\n\n\n\n\n","category":"function"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"constrainedLCS","category":"page"},{"location":"elliptic/#CoherentStructures.constrainedLCS","page":"Geodesic vortices","title":"CoherentStructures.constrainedLCS","text":"constrainedLCS(T::AbstractArray, xspan, yspan, p; kwargs...)\nconstrainedLCS(T::AxisArray, p; kwargs...)\n\nComputes constrained transport barriers as closed orbits of the transport vector field on the 2D computational grid spanned by xspan and yspan. p is an LCSParameters-type container of computational parameters. Returns a list of EllipticBarrier-type objects.\n\nThe keyword arguments and their default values are:\n\noutermost=true: only the outermost barriers, i.e., the vortex   boundaries are returned, otherwise all detected transport barrieres;\nverbose=true: show intermediate computational information\ndebug=false: whether to use the debug mode, which avoids parallelization   for more precise error messages.\n\n\n\n\n\n","category":"function"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"One of their arguments is a list of parameters used in the LCS detection. This list is combined in a data type called LCSParameters. The output is a list of EllipticBarriers and a list of Singularitys. There is an option to retrieve all closed barriers (outermost=false), in contrast to extracting only the outermost vortex boundaries (outermost=true), which is more efficient.","category":"page"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"The meta-functions consist of two steps: first, the index theory-based determination of where to search for closed orbits,, cf. Index theory-based placement of Poincaré sections; second, the closed orbit computation, cf. Closed orbit detection.","category":"page"},{"location":"elliptic/#Specific-types-1","page":"Geodesic vortices","title":"Specific types","text":"","category":"section"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"These are the specifically introduced types for elliptic LCS computations.","category":"page"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"LCSParameters\nEllipticBarrier\nEllipticVortex","category":"page"},{"location":"elliptic/#CoherentStructures.LCSParameters","page":"Geodesic vortices","title":"CoherentStructures.LCSParameters","text":"Container for parameters used in elliptic LCS computations.\n\nFields\n\nboxradius: \"radius\" of localization square for closed orbit detection\nindexradius=1e-1boxradius: radius for singularity type detection\nmerge_heuristics: a list of heuristics for combining singularities, supported are\ncombine_20: merge isolated singularity pairs that are mutually nearest neighbors\ncombine_31: merge 1 trisector + nearest-neighbor 3 wedge configurations.\ncombine_20_aggressive: an additional wedge combination heuristic\nn_seeds=100: number of seed points on the Poincaré section\npmin=0.7: lower bound on the parameter in the eta-field\npmax=2.0: upper bound on the parameter in the eta-field\nrdist=1e-4boxradius: required return distances for closed orbits\ntolerance_ode=1e-8boxradius: absolute and relative tolerance in orbit integration\nmaxiters_ode::Int=2000: maximum number of integration steps\nmax_orbit_length=8boxradius: maximum length of orbit length\nmaxiters_bisection::Int=20: maximum steps in bisection procedure\nonly_enclosing::Bool=true: whether the orbit must enclose the starting point of the Poincaré section\nonly_smooth::Bool=true: whether or not to reject orbits with \"corners\".\nonly_uniform::Bool=true: whether or not to reject orbits that are not uniform\n\nExample\n\njulia> p = LCSParameters(2.5)\nLCSParameters(2.5, 0.25, true, 100, 0.7, 2.0, 0.00025, 2.5e-8, 1000, 20.0, 30)\n\n\n\n\n\n","category":"type"},{"location":"elliptic/#CoherentStructures.EllipticBarrier","page":"Geodesic vortices","title":"CoherentStructures.EllipticBarrier","text":"This is a container for coherent vortex boundaries. An object vortex of type EllipticBarrier can be easily plotted by plot(vortex.curve), or plot!([figure, ]vortex.curve) if it is to be overlaid over an existing plot.\n\nFields\n\ncurve: a vector of tuples, contains the coordinates of coherent vortex boundary points;\ncore: location of the vortex core;\np: contains the parameter value of the direction field eta_lambda^pm, for which the curve is a closed orbit;\ns: a Bool value, which encodes the sign in the formula of the direction field eta_lambda^pm via the formula (-1)^s.\n\n\n\n\n\n","category":"type"},{"location":"elliptic/#CoherentStructures.EllipticVortex","page":"Geodesic vortices","title":"CoherentStructures.EllipticVortex","text":"This is a container for an elliptic vortex, as represented by the vortex's center and a list barriers of all computed EllipticBarriers.\n\nFields\n\ncenter: location of the vortex center;\nbarriers: vector of EllipticBarriers.\n\n\n\n\n\n","category":"type"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"Another one is Singularity, which comes along with some convenience functions.","category":"page"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"Singularity\ngetcoords\ngetindices","category":"page"},{"location":"elliptic/#CoherentStructures.Singularity","page":"Geodesic vortices","title":"CoherentStructures.Singularity","text":"Container type for critical points of vector fields or singularities of line fields.\n\nFields\n\ncoords::SVector{2}: coordinates of the singularity\nindex::Rational: index of the singularity\n\n\n\n\n\n","category":"type"},{"location":"elliptic/#CoherentStructures.getcoords","page":"Geodesic vortices","title":"CoherentStructures.getcoords","text":"getcoords(singularities)\n\nExtracts the coordinates of singularities, a vector of Singularitys. Returns a vector of SVectors.\n\n\n\n\n\n","category":"function"},{"location":"elliptic/#CoherentStructures.getindices","page":"Geodesic vortices","title":"CoherentStructures.getindices","text":"getindices(singularities)\n\nExtracts the indices of singularities, a vector of Singularitys.\n\n\n\n\n\n","category":"function"},{"location":"elliptic/#Index-theory-based-placement-of-Poincaré-sections-1","page":"Geodesic vortices","title":"Index theory-based placement of Poincaré sections","text":"","category":"section"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"This is performed by singularity_detection for line fields (such as eigenvector fields of symmetric positive-definite tensor fields) and by critical_point_detection for classic vector fields.","category":"page"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"singularity_detection\ncritical_point_detection","category":"page"},{"location":"elliptic/#CoherentStructures.singularity_detection","page":"Geodesic vortices","title":"CoherentStructures.singularity_detection","text":"singularity_detection(T, combine_distance; merge_heuristics=[combine_20]) -> Vector{Singularity}\n\nCalculate line-field singularities of the first eigenvector of T by taking a discrete differential-geometric approach. Singularities are calculated on each cell. Singularities with distance less or equal to combine_distance are combined by averaging the coordinates and adding the respective indices. The heuristics listed in merge_heuristics are used to merge singularities, cf. LCSParameters.\n\nReturn a vector of Singularitys.\n\n\n\n\n\n","category":"function"},{"location":"elliptic/#CoherentStructures.critical_point_detection","page":"Geodesic vortices","title":"CoherentStructures.critical_point_detection","text":"critical_point_detection(vs, combine_distance, dist=s1dist; merge_heuristics=[combine_20]) -> Vector{Singularity}\n\nComputes critical points of a vector/line field vs, given as an AxisArray. Critical points with distance less or equal to combine_distance are combined by averaging the coordinates and adding the respective indices. The argument dist is a signed distance function for angles: choose s1dist for vector fields, and p1dist for line fields; cf. compute_singularities. Heuristics listed as functions in merge_heuristics, cf. LCSParameters, are applied to combine singularities.\n\nReturns a vector of Singularitys.\n\n\n\n\n\n","category":"function"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"This function takes three steps. The first two are:","category":"page"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"compute_singularities\ncombine_singularities","category":"page"},{"location":"elliptic/#CoherentStructures.compute_singularities","page":"Geodesic vortices","title":"CoherentStructures.compute_singularities","text":"compute_singularities(v, dist=s1dist) -> Vector{Singularity}\n\nComputes critical points and singularities of vector and line fields v, respectively. The argument dist is a signed distance function for angles. Choose s1dist (default) for vector fields, and p1dist for line fields.\n\n\n\n\n\n","category":"function"},{"location":"elliptic/#CoherentStructures.combine_singularities","page":"Geodesic vortices","title":"CoherentStructures.combine_singularities","text":"combine_singularities(sing_coordinates, sing_indices, combine_distance) -> Vector{Singularity}\n\nThis function does the equivalent of: build a graph where singularities are vertices, and two vertices share an edge iff the coordinates of the corresponding vertices (given by sing_coordinates) have a distance leq combine_distance. Find all connected components of this graph, and return a list of their mean coordinate and sum of sing_indices.\n\n\n\n\n\n","category":"function"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"The third step is a postprocessing step, in which detected singularities are merged according to different heuristics.","category":"page"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"combine_20\ncombine_20_aggressive\ncombine_31","category":"page"},{"location":"elliptic/#CoherentStructures.combine_20","page":"Geodesic vortices","title":"CoherentStructures.combine_20","text":"combine_20(singularities)\n\nDetermines singularities which are mutually closest neighbors and combines them as one, while adding their indices.\n\n\n\n\n\n","category":"function"},{"location":"elliptic/#CoherentStructures.combine_20_aggressive","page":"Geodesic vortices","title":"CoherentStructures.combine_20_aggressive","text":"combine_20_aggressive(singularities)\n\nA heuristic for combining singularities which is likely to have a lot of false positives.\n\n\n\n\n\n","category":"function"},{"location":"elliptic/#CoherentStructures.combine_31","page":"Geodesic vortices","title":"CoherentStructures.combine_31","text":"combine_31(singularities)\n\nTakes the list of singularities in singularities and combines them so that any -1/2 singularity whose three nearest neighbors are 1/2 singularities becomes an elliptic region, provided that the -1/2 singularity is in the triangle spanned by the wedges. This configuration is common for OECS, applying to material barriers on a large turbulent example yielded only about an additional 1% material barriers.\n\n\n\n\n\n","category":"function"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"The function compute_singularities requires one of two signed distance functions for angles. These are s1dist for vector fields, and p1dist for line fields.","category":"page"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"s1dist\np1dist","category":"page"},{"location":"elliptic/#CoherentStructures.s1dist","page":"Geodesic vortices","title":"CoherentStructures.s1dist","text":"s1dist(α, β)\n\nComputes the signed length of the angle of the shortest circle segment going from angle β to angle α, as computed on the full circle.\n\nExamples\n\njulia> s1dist(π/2, 0)\n1.5707963267948966\n\njulia> s1dist(0, π/2)\n-1.5707963267948966\n\n\n\n\n\n","category":"function"},{"location":"elliptic/#CoherentStructures.p1dist","page":"Geodesic vortices","title":"CoherentStructures.p1dist","text":"p1dist(α, β)\n\nComputes the signed length of the angle of the shortest circle segment going from angle β to angle α [± π], as computed on the half circle.\n\nExamples\n\njulia> p1dist(π, 0)\n0.0\n\n\n\n\n\n","category":"function"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"From all virtual/merged singularities those with a suitable index are selected. Around each elliptic singularity the tensor field is localized and passed on for closed orbit detection.","category":"page"},{"location":"elliptic/#Closed-orbit-detection-1","page":"Geodesic vortices","title":"Closed orbit detection","text":"","category":"section"},{"location":"elliptic/#","page":"Geodesic vortices","title":"Geodesic vortices","text":"compute_returning_orbit\ncompute_closed_orbits","category":"page"},{"location":"elliptic/#CoherentStructures.compute_returning_orbit","page":"Geodesic vortices","title":"CoherentStructures.compute_returning_orbit","text":"compute_returning_orbit(vf, seed::SVector{2}, save::Bool=false, maxiters=2000, tolerance=1e-8, max_orbit_length=20.0)\n\nComputes returning orbits under the velocity field vf, originating from seed. The optional argument save controls whether intermediate locations of the returning orbit should be saved. Returns a tuple of orbit and statuscode (0 for success, 1 for maxiters reached, 2 for out of bounds error, 3 for other error).\n\n\n\n\n\n","category":"function"},{"location":"elliptic/#CoherentStructures.compute_closed_orbits","page":"Geodesic vortices","title":"CoherentStructures.compute_closed_orbits","text":"compute_closed_orbits(ps, ηfield, cache; rev=true, pmin=0.7, pmax=1.5, rdist=1e-4, tolerance_ode=1e-8, maxiters_ode=2000, maxiters_bisection=20)\n\nCompute the (outermost) closed orbit for a given Poincaré section ps, a vector field constructor ηfield, and an LCScache cache. Keyword arguments pmin and pmax correspond to the range of shift parameters in which closed orbits are sought; rev determines whether closed orbits are sought from the outside inwards (true) or from the inside outwards (false). rdist sets the required return distance for an orbit to be considered as closed. The parameter maxiters_ode gives the maximum number of steps taken by the ODE solver when computing the closed orbit, the ode solver uses tolerance given by tolerance_ode. The parameter maxiters_bisection gives the maximum number of iterations used by the bisection algorithm to find closed orbits.\n\n\n\n\n\n","category":"function"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"  EditURL = \"../../examples/ocean_flow.jl\"","category":"page"},{"location":"generated/ocean_flow/#Geostrophic-ocean-flow-1","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"","category":"section"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"tip: Tip\nThis example is also available as a Jupyter notebook: ocean_flow.ipynb, and as an executable julia file ocean_flow.jl.","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"For a more realistic application, we consider an unsteady ocean surface velocity data set obtained from satellite altimetry measurements produced by SSALTO/DUACS and distributed by AVISO. The particular space-time window has been used several times in the literature.","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"Below is a video showing advection of the initial 90-day DBS field for 90 days.","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"<video controls=\"\" height=\"100%\" width=\"100%\">\n <source src=\"https://raw.githubusercontent.com/natschil/misc/master/videos/ocean_flow.mp4\" type=\"video/mp4\" />\nYour browser does not support the video tag.\n</video>","category":"page"},{"location":"generated/ocean_flow/#Geodesic-vortices-1","page":"Geostrophic ocean flow","title":"Geodesic vortices","text":"","category":"section"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"Here, we demonstrate how to detect material barriers to diffusive transport.","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"using Distributed\nnprocs() == 1 && addprocs()\n\n@everywhere using CoherentStructures, OrdinaryDiffEq, StaticArrays","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"Next, we load and interpolate the velocity data sets. Loading the data sets defines Lon, Lat, Time, UT, VT.","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"using JLD2\nJLD2.@load(\"Ocean_geostrophic_velocity.jld2\")\nVI = interpolateVF(Lon, Lat, Time, UT, VT)","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"Since we want to use parallel computing, we set up the integration LCSParameters on all workers, i.e., @everywhere.","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"using AxisArrays\nq = 91\nt_initial = minimum(Time)\nt_final = t_initial + 90\ntspan = range(t_initial, stop=t_final, length=q)\nxmin, xmax, ymin, ymax = -4.0, 7.5, -37.0, -28.0\nnx = 300\nny = floor(Int, (ymax - ymin) / (xmax - xmin) * nx)\nxspan = range(xmin, stop=xmax, length=nx)\nyspan = range(ymin, stop=ymax, length=ny)\nP = AxisArray(SVector{2}.(xspan, yspan'), xspan, yspan)\nδ = 1.e-5\nmCG_tensor = let tspan=tspan, δ=δ, p=VI\n    u -> av_weighted_CG_tensor(interp_rhs, u, tspan, δ;\n        p=p, tolerance=1e-6, solver=Tsit5())\nend","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"Now, compute the averaged weighted Cauchy-Green tensor field and extract elliptic LCSs.","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"C̅ = pmap(mCG_tensor, P; batch_size=ceil(Int, length(P)/nprocs()^2))\np = LCSParameters(2.5)\nvortices, singularities = ellipticLCS(C̅, p)","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"Finally, the result is visualized as follows.","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"using Plots\ntrace = tensor_invariants(C̅)[5]\nfig = plot_vortices(vortices, singularities, (xmin, ymin), (xmax, ymax);\n    bg=trace, title=\"DBS field and transport barriers\", showlabel=true)","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"(Image: )","category":"page"},{"location":"generated/ocean_flow/#Objective-Eulerian-coherent-structures-(OECS)-1","page":"Geostrophic ocean flow","title":"Objective Eulerian coherent structures (OECS)","text":"","category":"section"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"With only minor modifications, we are also able to compute OECSs. We start by loading some packages and define the rate-of-strain tensor function.","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"using Interpolations, Tensors\n\nV = scale(interpolate(SVector{2}.(UT[:,:,1], VT[:,:,1]), BSpline(Quadratic(Free(OnGrid())))), Lon, Lat)\n\nrate_of_strain_tensor(xin) = let V=V\n    x, y = xin\n    grad = Interpolations.gradient(V, x, y)\n    df =  Tensor{2,2}((grad[1][1], grad[1][2], grad[2][1], grad[2][2]))\n    return symmetric(df)\nend","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"To make life more exciting, we choose a larger domain.","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"xmin, xmax, ymin, ymax = -12.0, 7.0, -38.1, -22.0\nnx = 950\nny = floor(Int, (ymax - ymin) / (xmax - xmin) * nx)\nxspan = range(xmin, stop=xmax, length=nx)\nyspan = range(ymin, stop=ymax, length=ny)\nP = AxisArray(SVector{2}.(xspan, yspan'), xspan, yspan)","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"Next, we evaluate the rate-of-strain tensor on the grid and compute OECSs. As there tend to be many 3 wedge + trisector-type singularity combinations with OECSs, we enable the combine_31 heuristic.","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"S = map(rate_of_strain_tensor, P)\np = LCSParameters(boxradius=2.5, pmin=-1, pmax=1, merge_heuristics=[combine_20, combine_31])\nvortices, singularities = ellipticLCS(S, p, outermost=true)","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"Finally, the result is visualized as follows, white are elliptic singularities, blue are trisectors and orange are wedges","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"λ₁ = tensor_invariants(S)[1]\nfig = plot_vortices(vortices, singularities, (xmin, ymin), (xmax, ymax);\n    bg=λ₁, logBg=false, title=\"Minor rate-of-strain field and OECSs\")","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"(Image: )","category":"page"},{"location":"generated/ocean_flow/#FEM-based-methods-1","page":"Geostrophic ocean flow","title":"FEM-based methods","text":"","category":"section"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"Here we showcase how the adaptive TO method can be used to calculate coherent sets.","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"First we setup the problem.","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"using CoherentStructures\nimport JLD2, OrdinaryDiffEq, Plots\n\nJLD2.@load(\"Ocean_geostrophic_velocity.jld2\")\n\nUV = interpolateVF(Lon, Lat, Time, UT, VT)","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"Next, we define a flow function from it.","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"t_initial = minimum(Time)\nt_final = t_initial + 90\ntimes = [t_initial, t_final]\nflow_map = u0 -> flow(interp_rhs, u0, times;\n    p=UV, tolerance=1e-5, solver=OrdinaryDiffEq.BS5())[end]","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"Next, we set up the domain. We want to use zero Dirichlet boundary conditions here.","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"LL = (-4.0, -34.0)\nUR = (6.0, -28.0)\nctx, _  = regularTriangularGrid((150, 90), LL, UR)\nbdata = getHomDBCS(ctx, \"all\");","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"For the TO method, we seek generalized eigenpairs involving the bilinear form","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"a_h(uv) = frac12 left(a_0(uv) + a_1(I_h u I_h v) right)","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"Here, a_0 is the weak form of the Laplacian on the initial domain, and a_1 is the weak form of the Laplacian on the final domain. The operator I_h is an interpolation operator onto the space of test functions on the final domain.","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"For the adaptive TO method, we use pointwise nodal interpolation (i.e. collocation) and the mesh on the final domain is obtained by doing a Delaunay triangulation on the images of the nodal points of the initial domain. This results in the representation matrix of I_h being the identity, so in matrix form we get:","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"S = 05(S_0 + S_1)","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"where S_0 is the stiffness matrix for the triangulation at initial time, and S_1 is the stiffness matrix for the triangulation at final time.","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"M = assembleMassMatrix(ctx, bdata=bdata)\nS0 = assembleStiffnessMatrix(ctx)\nS1 = adaptiveTOCollocationStiffnessMatrix(ctx, flow_map)","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"Averaging matrices and applying boundary conditions yields","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"S = applyBCS(ctx, 0.5(S0 + S1), bdata);","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"We can now solve the eigenproblem.","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"using Arpack\n\nλ, v = eigs(S, M, which=:SM, nev=6);","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"We upsample the eigenfunctions and then cluster.","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"using Clustering\n\nctx2, _ = regularTriangularGrid((200, 120), LL, UR)\nv_upsampled = sample_to(v, ctx, ctx2, bdata=bdata)\n\nfunction iterated_kmeans(numiterations, args...)\n    best = kmeans(args...)\n    for i in 1:(numiterations - 1)\n        cur = kmeans(args...)\n        if cur.totalcost < best.totalcost\n            best = cur\n        end\n    end\n    return best\nend\n\nn_partition = 4\nres = iterated_kmeans(20, permutedims(v_upsampled[:,1:(n_partition-1)]), n_partition)\nu = kmeansresult2LCS(res)\nu_combined = sum([u[:,i] * i for i in 1:n_partition])\nfig = plot_u(ctx2, u_combined, 200, 200;\n    color=:viridis, colorbar=:none, title=\"$n_partition-partition of Ocean Flow\")","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"(Image: )","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"","category":"page"},{"location":"generated/ocean_flow/#","page":"Geostrophic ocean flow","title":"Geostrophic ocean flow","text":"This page was generated using Literate.jl.","category":"page"},{"location":"fem/#Finite-element-discretizations-of-the-dynamic-Laplacian-1","page":"FEM-based methods","title":"Finite-element discretizations of the dynamic Laplacian","text":"","category":"section"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"These methods rely on the theory outlined by Froyland's Dynamical Laplacian and the Geometric Heat Flow of Karrasch & Keller.","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"The Laplace-like operators are best discretized by finite-element-based methods, see this paper by Froyland & Junge.","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"This involves the discretization of the average of a one-parameter family of Laplace operators of the form:","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"Delta^dyn = sum_t in mathcal T P_t^* Delta P_t","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"for a finite series of times mathcal T, where P_t is the transfer-operator for the flow at time t (in volume-preserving flows).","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"The resulting operator is both symmetric and uniformly elliptic. Eigenfunctions of Delta^dyn can be used to find Lagrangian Coherent Structures.","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"See the Examples section for examples of how these methods can be used.","category":"page"},{"location":"fem/#Features-1","page":"FEM-based methods","title":"Features","text":"","category":"section"},{"location":"fem/#CG-and-TO-methods-1","page":"FEM-based methods","title":"CG and TO methods","text":"","category":"section"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"The standard Galerkin formulation of the weak dynamical Laplace is referred to as the CG-method here, due to the fact that the inverse Cauchy-Green tensor appears in the weak formulation. This gives a bilinear form overline a(uv) = sum_t in mathcal Ta^t(P_t u P_t v) Here P_t is the Transfer-Operator (or pushforward) to time-t, and a^t is the weak-form of the Laplacian on the range of the time-t map being considered.","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"There is also a range of transfer operator-based approaches implemented here. These approximate the weak form of the Dynamical-Laplace by a bilinear-form:","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"tilde a_h(uv) = sum_t in mathcal T a^t(I_hP_t u I_h P_t v)","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"where I_h is a suitable interpolation operator depending on the mesh-width h. Options for I_h implemented in this package are:","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"collocation (pointwise interpolation):\npoints used are mesh points from domain grid (\"adaptive TO\"),\npoints used are arbitrary (\"non-adaptive TO\");\nthe L^2-orthogonal projection onto an FEM-space:\nusing the forward-flow map (currently gives poor results),\nusing the inverse flow map.","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"Note that the L^2-Galerkin methods currently perform very poorly on larger problems.","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"For more details, see Froyland & Junge, 2018.","category":"page"},{"location":"fem/#Grids-1","page":"FEM-based methods","title":"Grids","text":"","category":"section"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"Various types of regular and irregular meshes (with Delaunay triangulation using VoronoiDelaunay.jl ) are supported. These are based on the corresponding elements from JuAFEM.jl and include:","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"triangular P1-Lagrange elements in 2D (all methods)\nquadrilateral P1-Lagrange elements in 2D (all methods except adaptive TO)\ntriangular and quadrilateral P2-Lagrange elements in 2D (all methods except adaptive TO)\ntetrahedral P1-Lagrange elements in 3D (only CG method tested, non-adaptive TO might work also)","category":"page"},{"location":"fem/#The-GridContext-Type-1","page":"FEM-based methods","title":"The GridContext Type","text":"","category":"section"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"The FEM-based methods of CoherentStructures.jl rely heavily on the JuAFEM.jl package. This package is very low-level and does not provide point-location/plotting functionality. To be able to more conveniently work with the specific types of grids that we need, all necessary variables for a single grid are combined in a GridContext structure - including the grid points, the quadrature formula used and the type of element used (e.g. Triangular P1, Quadrilateral P2, etc..). This makes it easier to assemble mass/stiffness matrices, and provides an interface for point-location and plotting.","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"In this documentation, the variable name ctx is exclusively used for GridContext objects.","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"See also Constructing Grids in the FEM-API section.","category":"page"},{"location":"fem/#Node-ordering-and-dof-ordering-1","page":"FEM-based methods","title":"Node ordering and dof ordering","text":"","category":"section"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"Finite Element methods work with degrees of freedom (dof), which are elements of some dual space. For nodal finite elements, these correspond to evaluation functionals at the nodes of the grid.","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"The nodes of the grid can be obtained in the following way [n.x for n in ctx.grid.nodes]. However, most of the methods of this package do not return results in this order, but instead use JuAFEM.jl's dof-ordering.","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"See also the documentation in dof2node and CoherentStructures.GridContext","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"When working with (non-natural) Boundary Conditions, the ordering is further changed, due to there being fewer degrees of freedom in total.","category":"page"},{"location":"fem/#Assembly-1","page":"FEM-based methods","title":"Assembly","text":"","category":"section"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"See Stiffness and Mass Matrices from the FEM-API section.","category":"page"},{"location":"fem/#Evaluating-Functions-in-the-Approximation-Space-1","page":"FEM-based methods","title":"Evaluating Functions in the Approximation Space","text":"","category":"section"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"given a series of coefficients that represent a function in the approximation space, to evaluate a function at a point, use the evaluate_function_from_node_or_cellvals or evaluate_function_from_dofvals functions.","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"using CoherentStructures #hide\nusing Plots, Tensors\nctx, _ = regularP2TriangularGrid((10, 10))\nu = zeros(ctx.n)\nu[45] = 1.0\nPlots.heatmap(range(0, stop=1, length=200),range(0, stop=1, length=200),\n    (x, y) -> evaluate_function_from_dofvals(ctx, u, Vec(x, y)))","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"For more details, consult the API: evaluate_function_from_dofvals, evaluate_function_from_node_or_cellvals, evaluate_function_from_node_or_cellvals_multiple","category":"page"},{"location":"fem/#Nodal-Interpolation-1","page":"FEM-based methods","title":"Nodal Interpolation","text":"","category":"section"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"To perform nodal interpolation of a grid, use the nodal_interpolation function.","category":"page"},{"location":"fem/#Boundary-Conditions-1","page":"FEM-based methods","title":"Boundary Conditions","text":"","category":"section"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"To use something other than the natural homogeneous von Neumann boundary conditions, the BoundaryData type can be used. This currently supports combinations of homogeneous Dirichlet and periodic boundary conditions.","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"Homogeneous Dirichlet BCs require rows and columns of the stiffness/mass matrices to be deleted\nPeriodic boundary conditions require rows and columns of the stiffness/mass matrices to be added to each other.","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"This means that the coefficient vectors for elements of the approximation space that satisfy the boundary conditions are potentially smaller and in a different order. Given a bdata argument, functions like plot_u will take this into account.","category":"page"},{"location":"fem/#Constructing-Boundary-Conditions-1","page":"FEM-based methods","title":"Constructing Boundary Conditions","text":"","category":"section"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"Natural von-Neumann boundary conditions can be constructed with: BoundaryData() and are generally the default","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"Homogeneous Dirichlet boundary conditions can be constructed with the getHomDBCS(ctx[, which=\"all\"]) function. The optional which parameter is a vector of strings, corresponding to JuAFEM face-sets, e.g. getHomDBCS(ctx, which=[\"left\", \"right\"])","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"Periodic boundary conditions are constructed by calling BoundaryData(ctx,predicate,[which_dbc=[]]). The argument predicate is a function that should return true if and only if two points should be identified. Due to floating-point rounding errors, note that using exact comparisons (==) should be avoided. Only points that are in JuAFEM.jl boundary facesets are considered. If this is too restrictive, use the BoundaryData(dbc_dofs, periodic_dofs_from, periodic_dofs_to) constructor.","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"For details, see BoundaryData.","category":"page"},{"location":"fem/#Example-1","page":"FEM-based methods","title":"Example","text":"","category":"section"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"Here we apply homogeneous DBC to top and bottom, and identify the left and right side:","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"using CoherentStructures, Distances, Plots\nctx, _ = regularQuadrilateralGrid((10, 10))\npredicate = (p1, p2) -> peuclidean(p1, p2, [1.0, Inf]) < 2e-10\nbdata = BoundaryData(ctx, predicate, [\"top\", \"bottom\"])\nu = ones(nBCDofs(ctx, bdata))\nu[20] = 2.0; u[38] = 3.0; u[56] = 4.0\nplot_u(ctx, u, 200, 200, bdata=bdata, colorbar=:none)","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"To apply boundary conditions to a stiffness/mass matrix, use the applyBCS function. Note that assembleStiffnessMatrix and assembleMassMatrix take a bdata argument that does this internally.","category":"page"},{"location":"fem/#Plotting-and-Videos-1","page":"FEM-based methods","title":"Plotting and Videos","text":"","category":"section"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"There are some helper functions that exist for making plots and videos of functions on grids. These rely on the Plots.jl library. Plotting recipes are unfortunately not implemented.","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"The simplest way to plot is using the plot_u function. Plots and videos of eulerian plots like f circ Phi^0_t can be made with the plot_u_eulerian and  eulerian_videos functions.","category":"page"},{"location":"fem/#Parallelisation-1","page":"FEM-based methods","title":"Parallelisation","text":"","category":"section"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"Many of the plotting functions support parallelism internally. Tensor fields can be constructed in parallel, and then passed to assembleStiffnessMatrix. For an example that does this, see TODO: Add this example","category":"page"},{"location":"fem/#FEM-API-1","page":"FEM-based methods","title":"FEM-API","text":"","category":"section"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"CurrentModule = CoherentStructures","category":"page"},{"location":"fem/#Stiffness-and-Mass-Matrices-1","page":"FEM-based methods","title":"Stiffness and Mass Matrices","text":"","category":"section"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"assembleStiffnessMatrix\nassembleMassMatrix\nadaptiveTOCollocationStiffnessMatrix","category":"page"},{"location":"fem/#CoherentStructures.assembleStiffnessMatrix","page":"FEM-based methods","title":"CoherentStructures.assembleStiffnessMatrix","text":"assembleStiffnessMatrix(ctx, A, p=nothing; bdata=BoundaryData())\n\nAssemble the stiffness-matrix for a symmetric bilinear form\n\na(uv) = int nabla u(x)cdot A(x)nabla v(x)f(x) dx\n\nThe integral is approximated using numerical quadrature. A is a function that returns a SymmetricTensor{2,dim} object and must have one of the following signatures:\n\nA(x::Vector{Float64});\nA(x::Vec{dim});\nA(x::Vec{dim}, index::Int, p). Here, x is equal to ctx.quadrature_points[index], and p is the one passed to assembleStiffnessMatrix.\n\nThe ordering of the result is in dof order, except that boundary conditions from bdata are applied. The default is natural (homogeneous Neumann) boundary conditions.\n\n\n\n\n\n","category":"function"},{"location":"fem/#CoherentStructures.assembleMassMatrix","page":"FEM-based methods","title":"CoherentStructures.assembleMassMatrix","text":"assembleMassMatrix(ctx; bdata=BoundaryData(), lumped=false)\n\nAssemble the mass matrix\n\nM_ij = int varphi_j(x) varphi_i(x) f(x)dlambda^d\n\nThe integral is approximated using numerical quadrature. The values of f(x) are taken from ctx.mass_weights, and should be ordered in the same way as ctx.quadrature_points.\n\nThe result is ordered to be usable with a stiffness matrix with boundary data bdata.\n\nReturns a lumped mass matrix if lumped=true.\n\nExample\n\nctx.mass_weights = map(f, ctx.quadrature_points)\nM = assembleMassMatrix(ctx)\n\n\n\n\n\n","category":"function"},{"location":"fem/#CoherentStructures.adaptiveTOCollocationStiffnessMatrix","page":"FEM-based methods","title":"CoherentStructures.adaptiveTOCollocationStiffnessMatrix","text":"adaptiveTOCollocationStiffnessMatrix(ctx,flow_maps,times=nothing; [quadrature_order, on_torus,on_cylinder, LL, UR, bdata, volume_preserving=true,flow_map_mode=0] )\n\nCalculate the matrix-representation of the bilinear form a(uv) = 1N sum_n^N a_1(I_hT_nuI_hT_nv) where I_h is pointwise interpolation of the grid obtained by doing Delaunay triangulation on images of grid points from ctx and T_n is the Transfer-operator for x mapsto flow_maps(xtimes)n and a_1 is the weak form of the Laplacian on the codomain. Moreover, N in the equation above is equal to length(times) and t_n ranges over the elements of times.\n\nIf times==nothing, take N=1 above and use the map `x \\mapsto flow_maps(x) instead of the version with t_n.\n\nIf on_torus is true, the Delaunay Triangulation is done on the torus. If on_cylinder is true, then triangulation is done on cylinder (periodic) x. In both of these cases we require bdata for boundary information on the original domain as well as LL and UR as lower-left and upper-right corners of the image.\n\nIf volume_preserving == false, add a volumecorrection term to ``a1`` (See paper by Froyland & Junge).\n\nIf flow_map_mode==0, apply flow map to nodal basis function coordinates. If flow_map_mode==1, apply flow map to nodal basis function index number (allows for precomputed trajectories).\n\n\n\n\n\n","category":"function"},{"location":"fem/#Constructing-Grids-1","page":"FEM-based methods","title":"Constructing Grids","text":"","category":"section"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"There are several helper functions available for constructing grids. The simplest is:","category":"page"},{"location":"fem/#In-1D-1","page":"FEM-based methods","title":"In 1D","text":"","category":"section"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"regular1dP1Grid\nregular1dP2Grid","category":"page"},{"location":"fem/#CoherentStructures.regular1dP1Grid","page":"FEM-based methods","title":"CoherentStructures.regular1dP1Grid","text":"regular1dP1Grid(numnodes, left=0.0, right=1.0; [quadrature_order])\n\nCreate a regular grid with numnodes nodes on the interval [left, right] in 1d, with P1-Lagrange basis functions.\n\n\n\n\n\n","category":"function"},{"location":"fem/#CoherentStructures.regular1dP2Grid","page":"FEM-based methods","title":"CoherentStructures.regular1dP2Grid","text":"regular1dP2Grid(numnodes, left=0.0, right=1.0; [quadrature_order])\n\nCreate a regular grid with numnodes non-interior nodes on the interval [left, right], with P2-Lagrange elements.\n\n\n\n\n\n","category":"function"},{"location":"fem/#In-2D-1","page":"FEM-based methods","title":"In 2D","text":"","category":"section"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"regular2dGrid","category":"page"},{"location":"fem/#CoherentStructures.regular2dGrid","page":"FEM-based methods","title":"CoherentStructures.regular2dGrid","text":"regular2dGrid(gridType, numnodes, LL=(0.0,0.0), UR=(1.0,1.0); quadrature_order=default_quadrature_order)\n\nConstructs a regular grid. gridType should be one from regular2dGridTypes.\n\n\n\n\n\n","category":"function"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"Supported values for the gridType argument are:","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"using CoherentStructures #hide\nregular2dGridTypes","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"The following functions are conceptually similar:","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"regularTriangularGrid\nregularDelaunayGrid\nirregularDelaunayGrid\nregularP2TriangularGrid\nregularP2DelaunayGrid\nregularQuadrilateralGrid\nregularP2QuadrilateralGrid","category":"page"},{"location":"fem/#CoherentStructures.regularTriangularGrid","page":"FEM-based methods","title":"CoherentStructures.regularTriangularGrid","text":"regularTriangularGrid(numnodes, LL,UR;[quadrature_order, PC=false])\n\nCreate a regular triangular grid on a rectangle; does not use Delaunay triangulation internally. If\n\n\n\n\n\n","category":"function"},{"location":"fem/#CoherentStructures.regularDelaunayGrid","page":"FEM-based methods","title":"CoherentStructures.regularDelaunayGrid","text":"regularDelaunayGrid(numnodes=(25,25), LL=(0.0,0.0), UR=(1.0,1.0); [quadrature_order, on_torus=false, on_cylinder=false, nudge_epsilon=1e-5, PC=false])\n\nCreate a regular grid on a square with lower left corner LL and upper-right corner UR. Uses Delaunay triangulation internally. If on_torus==true, uses a periodic Delaunay triangulation in both directions. If on_cylinder==true uses a periodic Delaunay triangulatin in x direction only.  To avoid degenerate special cases, all nodes are given a random nudge, the strength of which depends on numnodes and nudge_epsilon. If PC==true, returns a piecewise constant grid. Else returns a P1-Lagrange grid.\n\n\n\n\n\n","category":"function"},{"location":"fem/#CoherentStructures.irregularDelaunayGrid","page":"FEM-based methods","title":"CoherentStructures.irregularDelaunayGrid","text":"irregularDelaunayGrid(nodes_in; [on_torus=false, on_cylinder=false, LL, UR, PC=false, ...])\n\nTriangulate the nodes nodes_in and return a GridContext and bdata for them. If on_torus==true, the triangulation is done on a torus. If PC==true, return a mesh with piecewise constant shape-functions, else P1 Lagrange.\n\n\n\n\n\n","category":"function"},{"location":"fem/#CoherentStructures.regularP2TriangularGrid","page":"FEM-based methods","title":"CoherentStructures.regularP2TriangularGrid","text":"regularP2TriangularGrid(numnodes=(25,25), LL=(0.0,0.0), UR=(1.0,1.0), quadrature_order=default_quadrature_order)\n\nCreate a regular P2 triangular grid on a rectangle. Does not use Delaunay triangulation internally.\n\n\n\n\n\n","category":"function"},{"location":"fem/#CoherentStructures.regularP2DelaunayGrid","page":"FEM-based methods","title":"CoherentStructures.regularP2DelaunayGrid","text":"regularP2DelaunayGrid(numnodes=(25,25), LL=(0.0,0.0), UR=(1.0,1.0), quadrature_order=default_quadrature_order)\n\nCreate a regular P2 triangular grid with numnodes being the number of (non-interior) nodes in each direction.\n\n\n\n\n\n","category":"function"},{"location":"fem/#CoherentStructures.regularQuadrilateralGrid","page":"FEM-based methods","title":"CoherentStructures.regularQuadrilateralGrid","text":"regularP2QuadrilateralGrid(numnodes, LL, UR; [quadrature_order, PC=false])\n\nCreate a regular P1 quadrilateral grid on a rectangle. If PC==true, use piecewise constant shape functions, otherwise use P1 Lagrange.\n\n\n\n\n\n","category":"function"},{"location":"fem/#CoherentStructures.regularP2QuadrilateralGrid","page":"FEM-based methods","title":"CoherentStructures.regularP2QuadrilateralGrid","text":"regularP2QuadrilateralGrid(numnodes=(25,25), LL=(0.0,0.0), UR=(1.0,1.0), quadrature_order=default_quadrature_order)\n\nCreate a regular P2 quadrilateral grid on a rectangle.\n\n\n\n\n\n","category":"function"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"In 3D we have","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"regularTetrahedralGrid\nregularP2TetrahedralGrid","category":"page"},{"location":"fem/#CoherentStructures.regularTetrahedralGrid","page":"FEM-based methods","title":"CoherentStructures.regularTetrahedralGrid","text":"regularTetrahedralGrid(numnodes=(10,10,10), LL=(0.0,0.0,0.0), UR=(1.0,1.0,1.0), quadrature_order=default_quadrature_order3D)\n\nCreate a regular P1 tetrahedral grid on a Cuboid in 3D. Does not use Delaunay triangulation internally.\n\n\n\n\n\n","category":"function"},{"location":"fem/#CoherentStructures.regularP2TetrahedralGrid","page":"FEM-based methods","title":"CoherentStructures.regularP2TetrahedralGrid","text":"regularP2TetrahedralGrid(numnodes=(10,10,10), LL=(0.0,0.0,0.0), UR=(1.0,1.0,1.0), quadrature_order=default_quadrature_order3D)\n\nCreate a regular P2 tetrahedral grid on a Cuboid in 3D. Does not use Delaunay triangulation internally.\n\n\n\n\n\n","category":"function"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"All of these methods return a GridContext object and a BoundaryData object. The latter is only relevant when using a Delaunay grid with on_torus==true.","category":"page"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"CoherentStructures.GridContext","category":"page"},{"location":"fem/#CoherentStructures.GridContext","page":"FEM-based methods","title":"CoherentStructures.GridContext","text":"mutable struct GridContext\n\nStores everything needed as \"context\" to be able to work on a FEM grid based on the JuAFEM package. Adds a point-locator API which facilitates plotting functions defined on the grid within Julia.\n\nFields\n\ngrid::JuAFEM.Grid, ip::JuAFEM.Interpolation, ip_geom::JuAFEM.Interpolation, qr::JuAFEM.QuadratureRule - see the JuAFEM package.\nloc::PointLocator: object used for point location on the grid.\nnode_to_dof::Vector{Int}: lookup table for dof index of a node (for Lagrange elements)\ndof_to_node::Vector{Int}: inverse of nodetodof\ncell_to_dof::Vector{Int}: lookup table for dof index of a cell (for piecewise constant elements)\ndof_to_cell::Vector{Int}: inverse of celltodof\nnum_nodes: number of nodes on the grid\nnum_cells: number of elements (e.g. triangles,quadrilaterals, ...) on the grid\nn: number of degrees of freedom (== num_nodes for Lagrange Elements, and == num_cells for piecewise constant elements)\nquadrature_points::Vector{Vec{dim,Float64}}: lists of all quadrature points on the grid, in a specific order.\nmass_weights::Vector{Float64}: weighting for stiffness/mass matrices.\nspatialBounds: if available, the corners of a bounding box of a domain. For regular grids, the bounds are tight.\nnumberOfPointsInEachDirection: for regular grids, how many (non-interior) nodes make up the regular grid.\ngridType: a string describing what kind of grid this is (e.g. \"regular triangular grid\")\nno_precompute=false: whether to precompute objects like quadrature points. Only enable this if you know what you are doing.\n\n\n\n\n\n","category":"type"},{"location":"fem/#Boundary-Conditions-API-1","page":"FEM-based methods","title":"Boundary Conditions API","text":"","category":"section"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"BoundaryData\ngetHomDBCS\nundoBCS\napplyBCS","category":"page"},{"location":"fem/#CoherentStructures.BoundaryData","page":"FEM-based methods","title":"CoherentStructures.BoundaryData","text":"mutable struct BoundaryData\n\nRepresent (a combination of) homogeneous Dirichlet and periodic boundary conditions.\n\nFields\n\ndbc_dofs: list of dofs that should have homogeneous Dirichlet boundary conditions. Must be sorted.\nperiodic_dofs_from and periodic_dofs_to are both Vector{Int}. The former must be strictly increasing, both must have the same length. periodic_dofs_from[i] is identified with periodic_dofs_to[i]. periodic_dofs_from[i] must be strictly larger than periodic_dofs_to[i]. Multiple dofs can be identified with the same dof. If some dof is identified with another dof and one of them is in dbc_dofs, both points must be in dbc_dofs.\n\n\n\n\n\n","category":"type"},{"location":"fem/#CoherentStructures.getHomDBCS","page":"FEM-based methods","title":"CoherentStructures.getHomDBCS","text":"getHomDBCS(ctx, which=\"all\")\n\nReturn BoundaryData object corresponding to homogeneous Dirichlet boundary conditions for a set of facesets. which=\"all\" is shorthand for [\"left\", \"right\", \"top\", \"bottom\"].\n\n\n\n\n\n","category":"function"},{"location":"fem/#CoherentStructures.undoBCS","page":"FEM-based methods","title":"CoherentStructures.undoBCS","text":"undoBCS(ctx, u, bdata)\n\nGiven a vector u in dof order with boundary conditions applied, return the corresponding u in dof order without the boundary conditions.\n\n\n\n\n\n","category":"function"},{"location":"fem/#CoherentStructures.applyBCS","page":"FEM-based methods","title":"CoherentStructures.applyBCS","text":"applyBCS(ctx_row, K, bdata_row; [ctx_col, bdata_col, bdata_row, add_vals=true])\n\nApply the boundary conditions from bdata_row and bdata_col to the sparse matrix K. Only applies boundary conditions accross columns (rows) if bdata_row==nothing (bdata_col==nothing). If add_vals==true (the default), then values in rows that should be cominbed are added. Otherwise, one of the rows is discarded and the values of the other are used.\n\n\n\n\n\n","category":"function"},{"location":"fem/#Helper-functions-1","page":"FEM-based methods","title":"Helper functions","text":"","category":"section"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"dof2node\ngetDofCoordinates","category":"page"},{"location":"fem/#CoherentStructures.dof2node","page":"FEM-based methods","title":"CoherentStructures.dof2node","text":"dof2node(ctx,u)\n\nInterprets u as an array of coefficients ordered in dof order, and reorders them to be in node order.\n\n\n\n\n\n","category":"function"},{"location":"fem/#CoherentStructures.getDofCoordinates","page":"FEM-based methods","title":"CoherentStructures.getDofCoordinates","text":"getDofCoordinates(ctx,dofindex)\n\nReturn the coordinates of the node corresponding to the dof with index dofindex.\n\n\n\n\n\n","category":"function"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"evaluate_function_from_dofvals\nevaluate_function_from_node_or_cellvals\nevaluate_function_from_node_or_cellvals_multiple","category":"page"},{"location":"fem/#CoherentStructures.evaluate_function_from_dofvals","page":"FEM-based methods","title":"CoherentStructures.evaluate_function_from_dofvals","text":"evaluate_function_from_dofvals(ctx, dofvals, x_in; outside_value=NaN,project_in=false)\n\nEvaluate the function at point x_in with coefficients of dofs given by dofvals (in dof-order). Return outside_value if point is out of bounds. Project the point into the domain if project_in==true. For evaluation at many points, or for many dofvals, the function evaluate_function_from_dofvals_multiple is more efficient.\n\n\n\n\n\n","category":"function"},{"location":"fem/#CoherentStructures.evaluate_function_from_node_or_cellvals","page":"FEM-based methods","title":"CoherentStructures.evaluate_function_from_node_or_cellvals","text":"evaluate_function_from_node_or_cellvals(ctx, vals, x_in; outside_value=0, project_in=false)\n\nLike evaluate_function_from_dofvals, but the coefficients from vals are assumed to be in node order. This is more efficient than evaluate_function_from_dofvals.\n\n\n\n\n\n","category":"function"},{"location":"fem/#CoherentStructures.evaluate_function_from_node_or_cellvals_multiple","page":"FEM-based methods","title":"CoherentStructures.evaluate_function_from_node_or_cellvals_multiple","text":"evaluate_function_from_node_or_cellvals_multiple(ctx, vals, xin; is_diag=false, kwargs...)\n\nLike evaluate_function_from_dofvals_multiple but uses node- (or cell- if piecewise constant interpolation) ordering for vals, which makes it slightly more efficient. If vals is a diagonal matrix, set is_diag to true for much faster evaluation.\n\n\n\n\n\n","category":"function"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"nodal_interpolation","category":"page"},{"location":"fem/#CoherentStructures.nodal_interpolation","page":"FEM-based methods","title":"CoherentStructures.nodal_interpolation","text":"nodal_interpolation(ctx,f)\n\nPerform nodal interpolation of a function. Returns a vector of coefficients in dof order.\n\n\n\n\n\n","category":"function"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"getH","category":"page"},{"location":"fem/#CoherentStructures.getH","page":"FEM-based methods","title":"CoherentStructures.getH","text":"getH(ctx)\n\nReturn the mesh width of a regular grid.\n\n\n\n\n\n","category":"function"},{"location":"fem/#Plotting-API-1","page":"FEM-based methods","title":"Plotting API","text":"","category":"section"},{"location":"fem/#FEM-1","page":"FEM-based methods","title":"FEM","text":"","category":"section"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"plot_u\nplot_u_eulerian\neulerian_videos\neulerian_video","category":"page"},{"location":"fem/#CoherentStructures.plot_u","page":"FEM-based methods","title":"CoherentStructures.plot_u","text":"plot_u(ctx, dof_vals, nx=100, ny=100, LL, UR; bdata=nothing, kwargs...)\n\nPlot the function with coefficients (in dof order, possible boundary conditions in bdata) given by dof_vals on the grid ctx. The domain to be plotted on is given by ctx.spatialBounds. The function is evaluated on a regular nx by ny grid, the resulting plot is a heatmap. Keyword arguments are passed down to plot_u_eulerian, which this function calls internally.\n\n\n\n\n\n","category":"function"},{"location":"fem/#CoherentStructures.plot_u_eulerian","page":"FEM-based methods","title":"CoherentStructures.plot_u_eulerian","text":"plot_u_eulerian(ctx, dof_vals, inverse_flow_map, LL, UR[, nx, ny];\n    euler_to_lagrange_points=nothing,\n    only_get_lagrange_points=false,\n    z=nothing,\n    postprocessor=nothing,\n    bdata=nothing,\n    kwargs...)\n\nPlot a heatmap of a function in Eulerian coordinates, i.e., the pushforward of f. This is given by f circ Phi^-1, f is a function defined on the grid ctx, represented by coefficients given by dof_vals (with possible boundary conditions given in bdata).\n\nThe argument inverse_flow_map is Phi^-1.\n\nThe resulting plot is on a regular nx x ny grid with lower left corner LL and upper right corner UR. Points that fall outside of the domain represented by ctx are plotted as NaN, which results in transparency.\n\nOne can pass values to be plotted directly by providing them in an array in the argument z. postprocessor can modify the values being plotted, return_scalar_field results in these values being returned. See the source code for further details.  Additional keyword arguments are passed to Plots.heatmap.\n\nInverse flow maps are computed in parallel if there are multiple workers.\n\n\n\n\n\n","category":"function"},{"location":"fem/#CoherentStructures.eulerian_videos","page":"FEM-based methods","title":"CoherentStructures.eulerian_videos","text":" eulerian_videos(ctx, us, inverse_flow_map_t, t0,tf, nx,ny,nt, LL,UR, num_videos=1;\n    extra_kwargs_fun=nothing, ...)\n\nCreate num_videos::Int videos in eulerian coordinates, i.e., where the time t is varied, plot f_i circ Phi_t^0 for f_1 dots.\n\nArguments\n\nus(i,t) is a vector of dofs to be plotted at time t for the ith video.\ninverse_flow_map_t(t,x) is Phi_t^0(x).\nt0, tf  are initial and final time.\nLL and UR are the coordinates of the domain's corners.\nnx, ny, and nt determine the number of points in each direction.\nextra_kwargs_fun(i,t) can be used to provide additional keyword arguments to Plots.heatmap().\n\nAdditional kwargs are passed on to plot_eulerian_video.\n\nAs much as possible is done in parallel.\n\nReturns a Vector of iterables result. Call Plots.animate(result[i]) to get an animation.\n\n\n\n\n\n","category":"function"},{"location":"fem/#CoherentStructures.eulerian_video","page":"FEM-based methods","title":"CoherentStructures.eulerian_video","text":"eulerian_video(ctx, u, inverse_flow_map_t, t0, tf, nx, ny, nt, LL, UR; extra_kwargs_fun=nothing, ...)\n\nLike eulerian_videos, but u(t) is a vector of dofs, and extra_kwargs_fun(t) gives extra keyword arguments. Returns only one result, on which Plots.animate() can be applied for an animation.\n\n\n\n\n\n","category":"function"},{"location":"fem/#Other-plotting-utilities-1","page":"FEM-based methods","title":"Other plotting utilities","text":"","category":"section"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"plot_ftle","category":"page"},{"location":"fem/#CoherentStructures.plot_ftle","page":"FEM-based methods","title":"CoherentStructures.plot_ftle","text":"plot_ftle(odefun, p, tspan, LL, UR, nx, ny;\n    δ=1e-9, tolerance=1e-4, solver=OrdinaryDiffEq.BS5(),\n    existing_plot=nothing, flip_y=false, check_inbounds=always_true, pass_on_errors=false)\n\nMake a heatmap of a FTLE field using finite differences. If existing_plot is given a value, plot using heatmap! on top of it. If flip_y is true, then flip the y-coordinate (needed sometimes due to a bug in Plots). Points where check_inbounds(x[1], x[2], p) == false are set to NaN, i.e., plotted transparently. Unless pass_on_errors is set to true, errors from calculating FTLE values are caught and ignored.\n\n\n\n\n\n","category":"function"},{"location":"fem/#Defaults-1","page":"FEM-based methods","title":"Defaults","text":"","category":"section"},{"location":"fem/#","page":"FEM-based methods","title":"FEM-based methods","text":"const default_quadrature_order=5\nconst default_solver = OrdinaryDiffEq.BS5()","category":"page"},{"location":"examples/#examples_section-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"As a quick hands-on introduction, we demonstrate the usage of the CoherentStructures.jl package on some classic flow problems. For references to the original works in which the methods were developed see the respective help page.","category":"page"},{"location":"examples/#List-of-examples-1","page":"Examples","title":"List of examples","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Rotating double gyre\nThe standard map\nBickley jet\nGeostrophic ocean flow\nWorking with trajectories","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"  EditURL = \"../../examples/trajectories.jl\"","category":"page"},{"location":"generated/trajectories/#Working-with-trajectories-1","page":"Working with trajectories","title":"Working with trajectories","text":"","category":"section"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"tip: Tip\nThis example is also available as a Jupyter notebook: trajectories.ipynb, and as an executable julia file trajectories.jl.","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"In the following, we demonstrate how to use coherent structure detection methods that work directly on trajectory data sets. These include the graph Laplace-based and the transfer operator-based methods for approximating the dynamic Laplacian.","category":"page"},{"location":"generated/trajectories/#Graph-Laplace-based-methods-1","page":"Working with trajectories","title":"Graph Laplace-based methods","text":"","category":"section"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"In the following, we demonstrate how to apply several graph Laplace-based coherent structure detection methods. For references and technical details, we refer to the corresponding Graph Laplacian/diffusion maps-based LCS methods page.","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"As an example, this is how we can add more processes to run code in parallel.","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"using Distributed\n(nprocs() == 1) && addprocs()","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"We first load our package and some dependencies.","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"@everywhere using CoherentStructures\nusing StaticArrays, Distances, Plots","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"Next, we define the usual flow parameters. For visualization convenience, we use a regular grid at initial time.","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"tspan = range(10*24*3600.0, stop=30*24*3600.0, length=41)\nm = 120; n = 41; N = m*n\nx = range(0.0, stop=20.0, length=m)\ny = range(-3.0, stop=3.0, length=n)\nf = u -> flow(bickleyJet, u, tspan, tolerance=1e-4)\nparticles = vec(SVector{2}.(x, y'))\ntrajectories = pmap(f, particles; batch_size=m)","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"The flow is defined on a cylinder with the following periods in x and y. The variable metric defines the (spatial) distance metric.","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"periods = [6.371π, Inf]\nmetric = PeriodicEuclidean(periods)","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"We would like calculate 6 diffusion coordinates for each example.","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"n_coords = 6","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"We now illustrate some of the different graph Laplace-based methods, and simply visualize some eigenvectors, mostly without further postprocessing.","category":"page"},{"location":"generated/trajectories/#Spectral-clustering-approach/L_1-time-averaging-[Hadjighasem,-Karrasch,-Teramoto-and-Haller,-2016]-1","page":"Working with trajectories","title":"Spectral-clustering approach/L_1 time averaging [Hadjighasem, Karrasch, Teramoto & Haller, 2016]","text":"","category":"section"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"ε = 3e-1\nkernel = gaussian(ε)\nP = sparse_diff_op(trajectories, Neighborhood(gaussiancutoff(ε/5)), kernel; metric=STmetric(metric, 1))\nλ, Ψ = diffusion_coordinates(P, n_coords)","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"We plot the second and third eigenvectors.","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"field = permutedims(reshape(Ψ[:, 2], m, n))\nfig = Plots.heatmap(x, y, field, aspect_ratio=1, color=:viridis)","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"(Image: )","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"field = permutedims(reshape(Ψ[:, 3], m, n))\nfig = Plots.heatmap(x, y, field, aspect_ratio=1, color=:viridis)","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"(Image: )","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"Another sparsification option is k-nearest neighbors. The following is a demonstration for 400 nearest, non-mutual neighbors. For the mutual nearest neighbors sparsification, choose MutualKNN().","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"P = sparse_diff_op(trajectories, KNN(400), kernel; metric=STmetric(metric, Inf))\nλ, Ψ = diffusion_coordinates(P, n_coords)\n\nfield = permutedims(reshape(Ψ[:, 2], m, n))\nfig = Plots.heatmap(x, y, field, aspect_ratio=1, color=:viridis)","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"(Image: )","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"field = permutedims(reshape(Ψ[:, 3], m, n))\nfig = Plots.heatmap(x, y, field, aspect_ratio=1, color=:viridis)","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"(Image: )","category":"page"},{"location":"generated/trajectories/#Use-of-SEBA-to-extract-features-1","page":"Working with trajectories","title":"Use of SEBA to extract features","text":"","category":"section"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"For feature extraction from operator eigenvectors, one may use the \"SEBA\" method developed by [Froyland, Rock & Sakellariou, 2019].","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"Ψ2 = SEBA(Ψ)","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"We plot two of the SEBA features extracted.","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"field = permutedims(reshape(Ψ2[:, 1], m, n))\nfig = Plots.heatmap(x, y, field, aspect_ratio=1, color=:viridis)","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"(Image: )","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"field = permutedims(reshape(Ψ2[:, 2], m, n))\nfig = Plots.heatmap(x, y, field, aspect_ratio=1, color=:viridis)","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"(Image: )","category":"page"},{"location":"generated/trajectories/#Space-time-diffusion-maps-[Banisch-and-Koltai,-2017]-1","page":"Working with trajectories","title":"Space-time diffusion maps [Banisch & Koltai, 2017]","text":"","category":"section"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"import Statistics: mean\nε = 1e-3\nkernel = gaussian(ε)\nP = sparse_diff_op_family(trajectories, Neighborhood(gaussiancutoff(ε)), kernel, mean; metric=metric)\nλ, Ψ = diffusion_coordinates(P, n_coords)\n\nfield = permutedims(reshape(Ψ[:, 2], m, n))\nfig = Plots.heatmap(x, y, field, aspect_ratio=1, color=:viridis)","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"(Image: )","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"field = permutedims(reshape(Ψ[:, 3], m, n))\nfig = Plots.heatmap(x, y, field, aspect_ratio=1, color=:viridis)","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"(Image: )","category":"page"},{"location":"generated/trajectories/#Network-based-approach-[Padberg-Gehle-and-Schneide,-2017]-1","page":"Working with trajectories","title":"Network-based approach [Padberg-Gehle & Schneide, 2017]","text":"","category":"section"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"ε = 0.2\nP = sparse_diff_op_family(trajectories, Neighborhood(ε), Base.one, P -> row_normalize!(min.(sum(P), 1));\n                            α=0, metric=metric)\nλ, Ψ = diffusion_coordinates(P, n_coords)\n\nfield = permutedims(reshape(Ψ[:, 2], m, n))\nfig = Plots.heatmap(x, y, field, aspect_ratio=1, color=:viridis)","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"(Image: )","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"field = permutedims(reshape(Ψ[:, 3], m, n))\nfig = Plots.heatmap(x, y, field, aspect_ratio=1, color=:viridis)","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"(Image: )","category":"page"},{"location":"generated/trajectories/#Time-coupled-diffusion-coordinates-[Marshall-and-Hirn,-2018]-1","page":"Working with trajectories","title":"Time coupled diffusion coordinates [Marshall & Hirn, 2018]","text":"","category":"section"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"ε = 1e-3\nkernel = gaussian(ε)\nP = sparse_diff_op_family(trajectories, Neighborhood(gaussiancutoff(ε)), kernel; metric=metric)\nλ, Ψ = diffusion_coordinates(P, n_coords)\n\nfield = permutedims(reshape(Ψ[:, 2], m, n))\nfig = Plots.heatmap(x, y, field, aspect_ratio=1, color=:viridis)","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"(Image: )","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"field = permutedims(reshape(Ψ[:, 3], m, n))\nfig = Plots.heatmap(x, y, field, aspect_ratio=1, color=:viridis)","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"(Image: )","category":"page"},{"location":"generated/trajectories/#FEM-adaptive-TO-method-1","page":"Working with trajectories","title":"FEM adaptive TO method","text":"","category":"section"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"We first generate some trajectories on a set of n random points for the rotating double gyre flow.","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"using CoherentStructures, StaticArrays, Tensors\n\nn = 500\ntspan = range(0, stop=1.0, length=20)\nxs, ys = rand(n), rand(n)\nparticles = SVector{2}.(xs, ys)\ntrajectories = [flow(rot_double_gyre, p, tspan) for p in particles]","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"Based on the initial particle positions we generate a triangulation. If this call fails or does not return, the initial positions may not be unique. In that case, simply generate a different set of random initial positions.","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"ctx, _ = irregularDelaunayGrid(Vec{2}.(particles))","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"Next, we generate the stiffness and mass matrices and solve the generalized eigenproblem.","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"S = adaptiveTOCollocationStiffnessMatrix(ctx, (i, ts) -> trajectories[i], tspan; flow_map_mode=1)\nM = assembleMassMatrix(ctx)\n\nusing Arpack\nλ, V = eigs(S, M; which=:SM, nev=6)","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"We can plot the computed spectrum.","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"using Plots\nfig = plot_real_spectrum(λ, label=\"\")","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"(Image: )","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"We may extract coherent vortices with k-means clustering.","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"using Clustering\nfunction iterated_kmeans(iterations, args...)\n    best = kmeans(args...)\n    for i in 1:(iterations - 1)\n        cur = kmeans(args...)\n        if cur.totalcost < best.totalcost\n            best = cur\n        end\n    end\n    return best.assignments\nend\n\npartitions = 3\nclusters = iterated_kmeans(20, permutedims(V[:, 2:partitions]), partitions)","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"A simple scatter plot visualization looks as follows.","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"fig = scatter(xs, ys, zcolor=clusters[ctx.node_to_dof], markersize=8, labels=\"\")","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"(Image: )","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"Alternatively, we may also plot the cluster assignments on the whole irregular grid.","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"fig = plot_u(ctx, float(clusters), 400, 400;\n                color=:viridis,\n                colorbar=:none,\n                title=\"$partitions-partition of rotating double gyre\")","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"(Image: )","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"","category":"page"},{"location":"generated/trajectories/#","page":"Working with trajectories","title":"Working with trajectories","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#CoherentStructures.jl-1","page":"Home","title":"CoherentStructures.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Tools for computing Lagrangian Coherent Structures in Julia","category":"page"},{"location":"#Introduction-1","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"CoherentStructures.jl is a toolbox for computing Lagrangian Coherent Structures (LCSs) by objective, i.e., observer-independent, methods in aperiodic flows in Julia. It has been developed in Oliver Junge's research group at TUM, Germany, by (in alphabetical order)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Alvaro de Diego (@adediego)\nOliver Junge (@gaioguy)\nDaniel Karrasch (@dkarrasch)\nNathanael Schilling (@natschil)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Contributions from colleagues in the field are most welcome via raising issues or, even better, via pull requests.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"First, install the JuAFEM.jl package by typing in the Julia REPL (console):","category":"page"},{"location":"#","page":"Home","title":"Home","text":"]add https://github.com/KristofferC/JuAFEM.jl.git","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Then, run the following in the Julia REPL:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"]add https://github.com/CoherentStructures/CoherentStructures.jl.git","category":"page"},{"location":"#Overview-of-supported-methods-1","page":"Home","title":"Overview of supported methods","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We currently support the following methods:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Finite-element discretizations of the dynamic Laplacian,\nGeodesic elliptic material vortices, such as \"black-hole vortices\", \"material barriers\" and \"OECS\", as well as\nGraph Laplacian/diffusion maps-based LCS methods for spectral clustering/diffusion maps inspired LCS approaches.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The graph Laplacian methods and the \"TO\" forms of the dynamic Laplacian FEM methods work directly on trajectories.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For more information on specific methods, consult the relevant pages of the documentation or the examples pages.","category":"page"},{"location":"#Examples-1","page":"Home","title":"Examples","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"As a quick hands-on introduction, we demonstrate the usage of the CoherentStructures.jl package on some classic flow problems. For references to the original works in which the methods were developed see the respective help page.","category":"page"},{"location":"#List-of-examples-1","page":"Home","title":"List of examples","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Rotating double gyre\nThe standard map\nBickley jet\nGeostrophic ocean flow\nWorking with trajectories","category":"page"}]
}
