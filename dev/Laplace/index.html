<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Graph Laplacian-based methods · CoherentStructures.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CoherentStructures.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../generated/rot_double_gyre/">Rotating double gyre</a></li><li><a class="toctext" href="../generated/standard_map/">Standard map</a></li><li><a class="toctext" href="../generated/bickley/">Bickley jet</a></li><li><a class="toctext" href="../generated/ocean_flow/">Geostrophic ocean flow</a></li><li><a class="toctext" href="../generated/trajectories/">Working with trajectories</a></li></ul></li><li><a class="toctext" href="../basics/">Basics</a></li><li><span class="toctext">Methods</span><ul><li><a class="toctext" href="../fem/">FEM-based methods</a></li><li><a class="toctext" href="../elliptic/">Geodesic vortices</a></li><li class="current"><a class="toctext" href>Graph Laplacian-based methods</a><ul class="internal"><li><a class="toctext" href="#Function-documentation-1">Function documentation</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Methods</li><li><a href>Graph Laplacian-based methods</a></li></ul><a class="edit-page" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/master/docs/src/Laplace.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Graph Laplacian-based methods</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Graph-Laplacian/diffusion-maps-based-LCS-methods-1" href="#Graph-Laplacian/diffusion-maps-based-LCS-methods-1">Graph Laplacian/diffusion maps-based LCS methods</a></h1><p>The LCS approaches implemented and described in this section are strongly influenced by ideas developed in the spectral clustering/diffusion maps communities. The general references include:</p><ul><li><a href="https://dx.doi.org/10.1109/34.868688">Shi &amp; Malik, Normalized cuts and image segmentation, 2000</a></li><li><a href="https://dx.doi.org/10.1016/j.acha.2006.04.006">Coifman &amp; Lafon, Diffusion maps, 2006</a></li><li><a href="https://dx.doi.org/10.1016/j.acha.2017.11.003">Marshall &amp; Hirn, Time coupled diffusion maps, 2018</a></li></ul><p>In the LCS context, these ideas have been adopted in the following works:</p><ul><li>somewhat related <a href="https://dx.doi.org/10.1063/1.4926372">Froyland &amp; Padberg-Gehle, 2015</a></li><li><a href="http://dx.doi.org/10.1103/PhysRevE.93.063107">Hadjighasem et al., 2016</a></li><li><a href="https://dx.doi.org/10.1063/1.4971788">Banisch &amp; Koltai, 2017</a></li><li><a href="https://dx.doi.org/10.5194/npg-24-189-2017">Rypina et al., 2017</a>/<a href="https://dx.doi.org/10.5194/npg-24-661-2017">Padberg-Gehle &amp; Schneide, 2018</a></li></ul><p>For demonstrations on example cases, please consult the page on <a href="../generated/trajectories/#Working-with-trajectories-1">Working with trajectories</a>.</p><h2><a class="nav-anchor" id="Function-documentation-1" href="#Function-documentation-1">Function documentation</a></h2><h3><a class="nav-anchor" id="Sparsification-methods-1" href="#Sparsification-methods-1">Sparsification methods</a></h3><p>Three commonly used sparsification methods are implemented for use with various graph Laplacian methods.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.KNN" href="#CoherentStructures.KNN"><code>CoherentStructures.KNN</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">KNN(k) &lt;: SparsificationMethod</code></pre><p>Defines the KNN (k-nearest neighbors) sparsification method. In this approach, first <code>k</code> nearest neighbors are sought. In the final graph Laplacian, only those particle pairs are included which are contained in some k-Neighborhood.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/e641cb5b1569299b542d01483bb928e6f3676d03/src/diffusion_operators.jl#L38-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.MutualKNN" href="#CoherentStructures.MutualKNN"><code>CoherentStructures.MutualKNN</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MutualKNN(k) &lt;: SparsificationMethod</code></pre><p>Defines the mutual KNN (k-nearest neighbors) sparsification method. In this approach, first <code>k</code> nearest neighbors are sought. In the final graph Laplacian, only those particle pairs are included which are mutually contained in each others k-Neighborhood.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/e641cb5b1569299b542d01483bb928e6f3676d03/src/diffusion_operators.jl#L50-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.Neighborhood" href="#CoherentStructures.Neighborhood"><code>CoherentStructures.Neighborhood</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Neighborhood(ε) &lt;: SparsificationMethod</code></pre><p>Defines the ε-Neighborhood sparsification method. In the final graph Laplacian, only those particle pairs are included which have distance less than <code>ε</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/e641cb5b1569299b542d01483bb928e6f3676d03/src/diffusion_operators.jl#L62-L67">source</a></section><p>Other sparsification methods can be implemented by defining a <code>SparsificationMethod</code> type and a corresponding <a href="#CoherentStructures.spdist"><code>spdist</code></a> method.</p><h3><a class="nav-anchor" id="Diffusion-maps-type/adjancency-matrix-based-graph-Laplacian-methods-1" href="#Diffusion-maps-type/adjancency-matrix-based-graph-Laplacian-methods-1">Diffusion-maps-type/adjancency-matrix-based graph Laplacian methods</a></h3><p>Since the Euclidean heat kernel is ubiquitous in diffusion maps-based computations, we provide it for convenience.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.gaussian" href="#CoherentStructures.gaussian"><code>CoherentStructures.gaussian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">gaussian(σ)</code></pre><p>Returns the Euclidean heat kernel as a callable function</p><div>\[x \mapsto \exp\left(-\frac{x^2}{4\sigma}\right)\]</div><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; kernel = gaussian(2.0);

julia&gt; kernel(0.)
1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/e641cb5b1569299b542d01483bb928e6f3676d03/src/diffusion_operators.jl#L3-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.gaussiancutoff" href="#CoherentStructures.gaussiancutoff"><code>CoherentStructures.gaussiancutoff</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">gaussiancutoff(σ, θ)</code></pre><p>Computes the positive value at which <a href="#CoherentStructures.gaussian"><code>gaussian</code></a> equals <code>θ</code>, i.e.,</p><div>\[\sqrt{-4\sigma\log(\theta)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/e641cb5b1569299b542d01483bb928e6f3676d03/src/diffusion_operators.jl#L25-L33">source</a></section><p>To compute a sparse distance matrix (or adjacency matrix, depending on the <a href="@Sparsification methods">sparsification method</a>), use <a href="#CoherentStructures.spdist"><code>spdist</code></a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.spdist" href="#CoherentStructures.spdist"><code>CoherentStructures.spdist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">spdist(data, sp_method, metric=Euclidean()) -&gt; SparseMatrixCSC</code></pre><p>Return a sparse distance matrix as determined by the sparsification method <code>sp_method</code> and <code>metric</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/e641cb5b1569299b542d01483bb928e6f3676d03/src/dynamicmetrics.jl#L211-L216">source</a></section><p>The main high-level functions for the above-listed methods are the following.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.sparse_diff_op_family" href="#CoherentStructures.sparse_diff_op_family"><code>CoherentStructures.sparse_diff_op_family</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sparse_diff_op_family(data, sp_method, kernel, op_reduce; α, metric, verbose)</code></pre><p>Return a list of sparse diffusion/Markov matrices <code>P</code>.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: a list of trajectories, each a list of states of type <code>SVector</code>;</li><li><code>sp_method</code>: a sparsification method;</li><li><code>kernel=gaussian()</code>: diffusion kernel, e.g., <a href="#CoherentStructures.gaussian"><code>gaussian</code></a>;</li><li><code>op_reduce=P -&gt; prod(LinearMaps.LinearMap, reverse(P))</code>: time-reduction of diffusion operators, e.g. <code>Statistics.mean</code> (space-time diffusion maps), <code>P -&gt; row_normalize!(max.(sum(P), 1))</code> (network-based coherence) or the default <code>P -&gt; prod(LinearMaps.LinearMap, reverse(P))</code> (time coupled diffusion maps)</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>α=1</code>: exponent in diffusion-map normalization;</li><li><code>metric=Euclidean()</code>: distance function w.r.t. which the kernel is computed, however, only for point pairs where <span>$metric(x_i, x_j)\leq \varepsilon$</span>;</li><li><code>verbose=false</code>: whether to print intermediate progress reports.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/e641cb5b1569299b542d01483bb928e6f3676d03/src/diffusion_operators.jl#L82-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.sparse_diff_op" href="#CoherentStructures.sparse_diff_op"><code>CoherentStructures.sparse_diff_op</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sparse_diff_op(data, sp_method, kernel; α=1, metric=Euclidean()) -&gt; SparseMatrixCSC</code></pre><p>Return a sparse diffusion/Markov matrix <code>P</code>.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: a list of trajectories, each a list of states of type <code>SVector</code>, or a list of states of type <code>SVector</code>;</li><li><code>sp_method</code>: a sparsification method;</li><li><code>kernel</code>: diffusion kernel, e.g., <a href="#CoherentStructures.gaussian"><code>gaussian</code></a>;</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>α</code>: exponent in diffusion-map normalization;</li><li><code>metric</code>: distance function w.r.t. which the kernel is computed, however, only for point pairs where <span>$metric(x_i, x_j)\leq \varepsilon$</span>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/e641cb5b1569299b542d01483bb928e6f3676d03/src/diffusion_operators.jl#L123-L138">source</a></section><h3><a class="nav-anchor" id="Normalization-functions-1" href="#Normalization-functions-1">Normalization functions</a></h3><p>In the diffusion maps framework, there are two commonly used normalization steps:</p><ol><li>kernel-density estimate normalization (<a href="#CoherentStructures.kde_normalize!"><code>kde_normalize!</code></a>), and</li><li>row normalization (<a href="#CoherentStructures.row_normalize!"><code>row_normalize!</code></a>), to obtain a diffusion/Markov operator (w.r.t. right- and left-action, respectively).</li></ol><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.kde_normalize!" href="#CoherentStructures.kde_normalize!"><code>CoherentStructures.kde_normalize!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">kde_normalize!(A, α=1)</code></pre><p>Normalize rows and columns of <code>A</code> in-place with the respective row-sum to the α-th power; i.e., return <span>$a_{ij}:=a_{ij}/q_i^{\alpha}/q_j^{\alpha}$</span>, where <span>$q_k = \sum_{\ell} a_{k\ell}$</span>. Default for <code>α</code> is <code>1</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/e641cb5b1569299b542d01483bb928e6f3676d03/src/diffusion_operators.jl#L167-L173">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.row_normalize!" href="#CoherentStructures.row_normalize!"><code>CoherentStructures.row_normalize!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">row_normalize!(A)</code></pre><p>Normalize rows of <code>A</code> in-place with the respective row-sum; i.e., return <span>$a_{ij}:=a_{ij}/q_i$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/e641cb5b1569299b542d01483bb928e6f3676d03/src/diffusion_operators.jl#L211-L216">source</a></section><h3><a class="nav-anchor" id="Diffusion-coordinate-like-functions-1" href="#Diffusion-coordinate-like-functions-1">Diffusion-coordinate-like functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.diffusion_coordinates" href="#CoherentStructures.diffusion_coordinates"><code>CoherentStructures.diffusion_coordinates</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">diffusion_coordinates(P, n_coords; maxiter=3000) -&gt; (Σ::Vector, Ψ::Matrix)</code></pre><p>Compute the (time-coupled) diffusion coordinates <code>Ψ</code> and the coordinate weights <code>Σ</code> for a diffusion operator <code>P</code>. <code>n_coords</code> determines the number of diffusion coordinates to be computed, <code>maxiter</code> is passed to <code>Arpack.eigs</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/e641cb5b1569299b542d01483bb928e6f3676d03/src/diffusion_operators.jl#L269-L275">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.diffusion_distance" href="#CoherentStructures.diffusion_distance"><code>CoherentStructures.diffusion_distance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">diffusion_distance(diff_coord) -&gt; SymmetricMatrix</code></pre><p>Returns the distance matrix of pairs of points whose diffusion distances correspond to the diffusion coordinates given by <code>diff_coord</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/e641cb5b1569299b542d01483bb928e6f3676d03/src/diffusion_operators.jl#L305-L310">source</a></section><footer><hr/><a class="previous" href="../elliptic/"><span class="direction">Previous</span><span class="title">Geodesic vortices</span></a></footer></article></body></html>
