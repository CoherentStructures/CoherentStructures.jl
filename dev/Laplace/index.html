<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Graph Laplacian-based methods · CoherentStructures.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CoherentStructures.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../generated/rot_double_gyre/">Rotating double gyre</a></li><li><a class="toctext" href="../generated/standard_map/">Standard map</a></li><li><a class="toctext" href="../generated/bickley/">Bickley jet</a></li><li><a class="toctext" href="../generated/ocean_flow/">Geostrophic ocean flow</a></li></ul></li><li><a class="toctext" href="../basics/">Basics</a></li><li><span class="toctext">Methods</span><ul><li><a class="toctext" href="../fem/">FEM-based methods</a></li><li><a class="toctext" href="../elliptic/">Geodesic vortices</a></li><li class="current"><a class="toctext" href>Graph Laplacian-based methods</a><ul class="internal"><li><a class="toctext" href="#Function-documentation-1">Function documentation</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Methods</li><li><a href>Graph Laplacian-based methods</a></li></ul><a class="edit-page" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/master/docs/src/Laplace.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Graph Laplacian-based methods</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Graph-Laplacian/diffusion-maps-based-LCS-methods-1" href="#Graph-Laplacian/diffusion-maps-based-LCS-methods-1">Graph Laplacian/diffusion maps-based LCS methods</a></h1><p>Cite a couple of important papers:</p><ul><li><a href="https://dx.doi.org/10.1109/34.868688">Shi &amp; Malik, Normalized cuts and image segmentation, 2000</a></li><li><a href="https://dx.doi.org/10.1016/j.acha.2006.04.006">Coifman &amp; Lafon, Diffusion maps, 2006</a></li><li><a href="https://dx.doi.org/10.1016/j.acha.2017.11.003">Marshall &amp; Hirn, Time coupled diffusion maps, 2018</a></li></ul><p>In the LCS context, we have</p><ul><li>somewhat related <a href="https://dx.doi.org/10.1063/1.4926372">Froyland &amp; Padberg-Gehle, 2015</a></li><li><a href="http://dx.doi.org/10.1103/PhysRevE.93.063107">Hadjighasem et al., 2016</a></li><li><a href="https://dx.doi.org/10.1063/1.4971788">Banisch &amp; Koltai, 2017</a></li><li><a href="https://dx.doi.org/10.5194/npg-24-189-2017">Rypina et al., 2017</a>/<a href="https://dx.doi.org/10.5194/npg-24-661-2017">Padberg-Gehle &amp; Schneide, 2018</a></li><li>De Diego et al., 2018</li></ul><h2><a class="nav-anchor" id="Function-documentation-1" href="#Function-documentation-1">Function documentation</a></h2><h3><a class="nav-anchor" id="Sparsification-methods-1" href="#Sparsification-methods-1">Sparsification methods</a></h3><p>Two commonly used sparsification methods are implemented for use with various graph Laplacian methods, see below.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.KNN" href="#CoherentStructures.KNN"><code>CoherentStructures.KNN</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">KNN(k)</code></pre><p>Defines the KNN (k-nearest neighbors) sparsification method. In this approach, first <code>k</code> nearest neighbors are sought. In the final graph Laplacian, only those particle pairs are included which are contained in some k-neighborhood.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/a525e3c4dff171bba9963933a0b46368b5bec000/src/diffusion_operators.jl#L7-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.mutualKNN" href="#CoherentStructures.mutualKNN"><code>CoherentStructures.mutualKNN</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mutualKNN(k)</code></pre><p>Defines the mutual KNN (k-nearest neighbors) sparsification method. In this approach, first <code>k</code> nearest neighbors are sought. In the final graph Laplacian, only those particle pairs are included which are mutually contained in each others k-neighborhood.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/a525e3c4dff171bba9963933a0b46368b5bec000/src/diffusion_operators.jl#L19-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.neighborhood" href="#CoherentStructures.neighborhood"><code>CoherentStructures.neighborhood</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">neighborhood(ε)</code></pre><p>Defines the ε-neighborhood sparsification method. In the final graph Laplacian, only those particle pairs are included which have distance less than <code>ε</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/a525e3c4dff171bba9963933a0b46368b5bec000/src/diffusion_operators.jl#L31-L36">source</a></section><p>Other sparsification methods can be implemented by defining a corresponding <a href="#CoherentStructures.sparseaffinitykernel"><code>sparseaffinitykernel</code></a> instance.</p><h3><a class="nav-anchor" id="Diffusion-maps-type-graph-Laplacian-methods-1" href="#Diffusion-maps-type-graph-Laplacian-methods-1">Diffusion-maps type graph Laplacian methods</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.diff_op" href="#CoherentStructures.diff_op"><code>CoherentStructures.diff_op</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">diff_op(data, sp_method, kernel = gaussian_kernel; α=1.0, metric=Euclidean&quot;()&quot;)</code></pre><p>Return a diffusion/Markov matrix <code>P</code>.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: 2D array with columns correspdonding to data points;</li><li><code>sp_method</code>: employed sparsification method (<a href="#CoherentStructures.neighborhood"><code>neighborhood</code></a> or <a href="#CoherentStructures.mutualKNN"><code>mutualKNN</code></a>);</li><li><code>kernel</code>: diffusion kernel, e.g., <code>x -&gt; exp(-x*x/4σ)</code>;</li><li><code>α</code>: exponent in diffusion-map normalization;</li><li><code>metric</code>: distance function w.r.t. which the kernel is computed, however, only for point pairs where <span>$metric(x_i, x_j)\leq \varepsilon$</span>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/a525e3c4dff171bba9963933a0b46368b5bec000/src/diffusion_operators.jl#L55-L67">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.sparse_diff_op_family" href="#CoherentStructures.sparse_diff_op_family"><code>CoherentStructures.sparse_diff_op_family</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sparse_diff_op_family(data, sp_method, kernel=gaussian_kernel, dim=2; op_reduce, α, metric)</code></pre><p>Return a list of sparse diffusion/Markov matrices <code>P</code>.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: 2D array with columns correspdonding to data points;</li><li><code>sp_method</code>: sparsification method;</li><li><code>kernel</code>: diffusion kernel, e.g., <code>x -&gt; exp(-x*x/4σ)</code>;</li><li><code>dim</code>: the columns are interpreted as concatenations of <code>dim</code>- dimensional points, to which <code>metric</code> is applied individually;</li><li><code>op_reduce</code>: time-reduction of diffusion operators, e.g. <code>mean</code> or <code>P -&gt; prod(LMs.LinearMap,Iterators.reverse(P))</code> (default)</li><li><code>α</code>: exponent in diffusion-map normalization;</li><li><code>metric</code>: distance function w.r.t. which the kernel is computed, however, only for point pairs where <span>$metric(x_i, x_j)\leq \varepsilon$</span>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/a525e3c4dff171bba9963933a0b46368b5bec000/src/diffusion_operators.jl#L118-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.sparse_diff_op" href="#CoherentStructures.sparse_diff_op"><code>CoherentStructures.sparse_diff_op</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sparse_diff_op(data, sp_method, kernel; α=1.0, metric=Euclidean()) -&gt; SparseMatrixCSC</code></pre><p>Return a sparse diffusion/Markov matrix <code>P</code>.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: 2D array with columns correspdonding to data points;</li><li><code>sp_method</code>: sparsification method;</li><li><code>kernel</code>: diffusion kernel, e.g., <code>x -&gt; exp(-x*x)</code> (default);</li><li><code>α</code>: exponent in diffusion-map normalization;</li><li><code>metric</code>: distance function w.r.t. which the kernel is computed, however, only for point pairs where <span>$metric(x_i, x_j)\leq \varepsilon$</span>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/a525e3c4dff171bba9963933a0b46368b5bec000/src/diffusion_operators.jl#L157-L169">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.sparseaffinitykernel" href="#CoherentStructures.sparseaffinitykernel"><code>CoherentStructures.sparseaffinitykernel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sparseaffinitykernel(data, sp_method, kernel, metric=Euclidean()) -&gt; SparseMatrixCSC</code></pre><p>Return a sparse matrix <code>W</code> where <span>$w_{ij} = k(x_i, x_j)$</span>. The <span>$x_i$</span> are taken from the columns of <code>data</code>. Entries are only calculated for pairs determined by the sparsification method <code>sp_method</code>. Default metric is <code>Euclidean()</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/a525e3c4dff171bba9963933a0b46368b5bec000/src/diffusion_operators.jl#L184-L191">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.kde_normalize!" href="#CoherentStructures.kde_normalize!"><code>CoherentStructures.kde_normalize!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">kde_normalize!(A, α = 1.0)</code></pre><p>Normalize rows and columns of <code>A</code> in-place with the respective row-sum to the α-th power; i.e., return <span>$a_{ij}:=a_{ij}/q_i^{\alpha}/q_j^{\alpha}$</span>, where <span>$q_k = \sum_{\ell} a_{k\ell}$</span>. Default for <code>α</code> is 1.0.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/a525e3c4dff171bba9963933a0b46368b5bec000/src/diffusion_operators.jl#L236-L241">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.wLap_normalize!" href="#CoherentStructures.wLap_normalize!"><code>CoherentStructures.wLap_normalize!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">wLap_normalize!(A)</code></pre><p>Normalize rows of <code>A</code> in-place with the respective row-sum; i.e., return <span>$a_{ij}:=a_{ij}/q_i$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/a525e3c4dff171bba9963933a0b46368b5bec000/src/diffusion_operators.jl#L262-L266">source</a></section><h3><a class="nav-anchor" id="Adjancency-matrix-based-graph-Laplacian-methods-1" href="#Adjancency-matrix-based-graph-Laplacian-methods-1">Adjancency-matrix-based graph Laplacian methods</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.sparse_adjacency" href="#CoherentStructures.sparse_adjacency"><code>CoherentStructures.sparse_adjacency</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sparse_adjacency(data, ε[, dim]; metric) -&gt; SparseMatrixCSC</code></pre><p>Return a sparse adjacency matrix <code>A</code> with integer entries <code>0</code> or <code>1</code>. If the third argument <code>dim</code> is passed, then <code>data</code> is interpreted as concatenated points of length <code>dim</code>, to which <code>metric</code> is applied individually. Otherwise, metric is applied to the whole columns of <code>data</code>.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: 2D array with columns correspdonding to data points;</li><li><code>ε</code>: distance threshold;</li><li><code>dim</code>: the columns of <code>data</code> are interpreted as concatenations of <code>dim</code>- dimensional points, to which <code>metric</code> is applied individually;</li><li><code>metric</code>: distance function w.r.t. which the kernel is computed, however, only for point pairs where <span>$metric(x_i, x_j)\leq \varepsilon$</span>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/a525e3c4dff171bba9963933a0b46368b5bec000/src/diffusion_operators.jl#L289-L304">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.sparse_adjacency_list" href="#CoherentStructures.sparse_adjacency_list"><code>CoherentStructures.sparse_adjacency_list</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sparse_adjacency_list(data, ε; metric=Euclidean()) -&gt; idxs::Vector{Vector}</code></pre><p>Return two lists of indices of data points that are adjacent.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: 2D array with columns correspdonding to data points;</li><li><code>ε</code>: distance threshold;</li><li><code>metric</code>: distance function w.r.t. which the kernel is computed, however, only for point pairs where <span>$metric(x_i, x_j)\leq \varepsilon$</span>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/a525e3c4dff171bba9963933a0b46368b5bec000/src/diffusion_operators.jl#L334-L344">source</a></section><h3><a class="nav-anchor" id="Diffusion-coordinate-like-functions-1" href="#Diffusion-coordinate-like-functions-1">Diffusion-coordinate-like functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.diffusion_coordinates" href="#CoherentStructures.diffusion_coordinates"><code>CoherentStructures.diffusion_coordinates</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">diffusion_coordinates(P,n_coords) -&gt; (Σ::Vector, Ψ::Matrix)</code></pre><p>Compute the (time-coupled) diffusion coordinates <code>Ψ</code> and the coordinate weights <code>Σ</code> for a linear map <code>P</code>. <code>n_coords</code> determines the number of diffusion coordinates to be computed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/a525e3c4dff171bba9963933a0b46368b5bec000/src/diffusion_operators.jl#L404-L410">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CoherentStructures.diffusion_distance" href="#CoherentStructures.diffusion_distance"><code>CoherentStructures.diffusion_distance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">diffusion_distance(diff_coord) -&gt; SymmetricMatrix</code></pre><p>Returns the distance matrix of pairs of points whose diffusion distances correspond to the diffusion coordinates given by <code>diff_coord</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/CoherentStructures/CoherentStructures.jl/blob/a525e3c4dff171bba9963933a0b46368b5bec000/src/diffusion_operators.jl#L440-L445">source</a></section><footer><hr/><a class="previous" href="../elliptic/"><span class="direction">Previous</span><span class="title">Geodesic vortices</span></a></footer></article></body></html>
